Got it‚Äîthis is a classic ‚Äúinputs look real but the scorer has nothing to chew on‚Äù situation. v3 is ranking off half-empty vectors, so depth vets with age/stability are floating to the top while true producers vanish.

Here‚Äôs a tight v3.1 hotpatch Tiber can drop in to make the engine recognize ‚Äúanalytics = fantasy points/xFP,‚Äù fill nulls, and only rank real, active players.

‚∏ª

üîß DeepSeek v3.1 Hotpatch (ratings ‚Üí rankings sanity)

A) Normalize layer: compute xFP + FPTS fallbacks

server/services/sleeperDataNormalizationService.ts

// NEW: import OLS coeffs from DEEPSEEK_V3_1_SYSTEM_BUNDLE.md
import coeffs from "../../config/deepseek.v3.1.ols.json"; 
// { WR: {...}, RB: {...}, TE: {...}, QB: {...} } with fields used below

export type NormalizedPlayer = {
  player_id: string; name: string; pos: "WR"|"RB"|"TE"|"QB"; team?: string; age?: number;
  games?: number;
  // season totals
  ppr?: number;    // season sum fantasy points (PPR)
  ppr_g?: number;  // per-game PPR
  last6_ppr_g?: number; // last 6 weeks PPR per game
  spike90?: number;     // 90th percentile weekly PPR
  // shares/opportunity (best effort)
  tgtShare?: number; rushShare?: number; routeRate?: number; rzTgtShare?: number; glRushShare?: number;
  // model targets
  xfp?: number;        // expected fantasy points (season)
  xfp_g?: number;      // per-game xFP
  // status
  status?: string;     // sleeper status code
};

// After fetching weekly stats (one row per player-week), build robust season aggregates:
function buildSeasonAgg(weeks: any[]): Record<string, NormalizedPlayer> {
  const byPlayer: Record<string, any[]> = {};
  for (const w of weeks) {
    if (!w.player_id) continue;
    (byPlayer[w.player_id] ??= []).push(w);
  }

  const out: Record<string, NormalizedPlayer> = {};
  for (const [pid, rows] of Object.entries(byPlayer)) {
    const pos = rows[0]?.position;
    if (!["WR","RB","TE","QB"].includes(pos)) continue;

    const games = rows.length;
    const pprWeeks = rows.map(r => Number(r.pts_ppr ?? 0));
    const ppr = pprWeeks.reduce((a,b)=>a+b,0);
    const ppr_g = games ? ppr / games : 0;
    const last6 = pprWeeks.slice(-6);
    const last6_ppr_g = last6.length ? last6.reduce((a,b)=>a+b,0) / last6.length : 0;
    const spike90 = percentile(pprWeeks, 0.90);

    // Shares (best-effort; guard nulls)
    const teamTar = sum(rows.map(r => Number(r.team_targets ?? 0)));
    const teamCar = sum(rows.map(r => Number(r.team_carries ?? 0)));
    const tar = sum(rows.map(r => Number(r.targets ?? 0)));
    const car = sum(rows.map(r => Number(r.carries ?? 0)));
    const tgtShare = teamTar ? tar / teamTar : undefined;
    const rushShare = teamCar ? car / teamCar : undefined;

    const routes = sum(rows.map(r => Number(r.routes_run ?? 0)));
    const snaps  = sum(rows.map(r => Number(r.offensive_snaps ?? 0)));
    const routeRate = snaps ? routes / snaps : undefined;

    const rzTar = sum(rows.map(r => Number(r.redzone_targets ?? 0)));
    const teamRzTar = sum(rows.map(r => Number(r.team_redzone_targets ?? 0)));
    const rzTgtShare = teamRzTar ? rzTar / teamRzTar : undefined;

    const glCar = sum(rows.map(r => Number(r.goline_carries ?? 0)));
    const teamGlCar = sum(rows.map(r => Number(r.team_goline_carries ?? 0)));
    const glRushShare = teamGlCar ? glCar / teamGlCar : undefined;

    // xFP via OLS (position-specific)
    const c = coeffs[pos] || {};
    // keep this lean: use available inputs, default to 0; model lives in bundle
    const xfp = rows.reduce((tot, r) => {
      const w = 
        (c.const ?? 0) +
        (c.targets ?? 0) * (Number(r.targets ?? 0)) +
        (c.receptions ?? 0) * (Number(r.receptions ?? 0)) +
        (c.carries ?? 0) * (Number(r.carries ?? 0)) +
        (c.air_yards ?? 0) * (Number(r.air_yards ?? 0)) +
        (c.endzone_tgts ?? 0) * (Number(r.endzone_targets ?? 0)) +
        (c.rz_tgts ?? 0) * (Number(r.redzone_targets ?? 0)) +
        (c.deep_tgts ?? 0) * (Number(r.deep_targets ?? 0)) +
        (c.yac ?? 0) * (Number(r.yac ?? 0)) +
        (c.rush_rz ?? 0) * (Number(r.redzone_carries ?? 0)) +
        (c.gl_carry ?? 0) * (Number(r.goline_carries ?? 0));
      return tot + w;
    }, 0);
    const xfp_g = games ? xfp / games : 0;

    out[pid] = {
      player_id: pid,
      name: rows[0]?.player_name ?? rows[0]?.full_name ?? rows[0]?.name ?? "Unknown",
      pos,
      team: rows[0]?.team,
      age: Number(rows[0]?.age ?? 0) || undefined,
      games, ppr, ppr_g, last6_ppr_g, spike90,
      tgtShare, rushShare, routeRate, rzTgtShare, glRushShare,
      xfp, xfp_g,
      status: rows[0]?.status
    };
  }
  return out;
}

function percentile(a:number[], p:number){
  if (!a.length) return 0;
  const s=[...a].sort((x,y)=>x-y);
  const idx=Math.min(s.length-1, Math.max(0, Math.floor(p*(s.length-1))));
  return s[idx];
}
function sum(a:number[]){return a.reduce((x,y)=>x+y,0);}

What this fixes
	‚Ä¢	Every ranked player now has ppr_g / xfp_g even if shares/routes are missing.
	‚Ä¢	‚ÄúAnalytics = fantasy points‚Äù is guaranteed: the score has real production.

‚∏ª

B) Scoring: prefer xFP/PPR when components are missing

server/services/deepseekV3Service.ts (replace component fns)

const clamp = (x:number, lo=0, hi=100)=>Math.max(lo, Math.min(hi, x));

// Position percentiles helper
function percentileWithinPos(players:any[], pos:string, getter:(p:any)=>number){
  const vals = players.filter(p=>p.pos===pos).map(getter).filter(v=>Number.isFinite(v));
  const sorted = vals.sort((a,b)=>a-b);
  return (v:number)=>{
    if (!sorted.length || !Number.isFinite(v)) return 50;
    let i = 0; while (i<sorted.length && v >= sorted[i]) i++;
    return clamp((i / sorted.length)*100);
  };
}

export async function buildDeepseekV3(mode:"dynasty"|"redraft"){
  const cfg = weights.mode_defaults[mode];
  // 1) pull normalized players with season aggregates
  const all = await getNormalizedPlayers(); // from normalization service above

  // 2) active filter (no FAs/retired/suspended)
  const ACTIVE = new Set(["Active","ACT","PRACTICE_SQUAD"]);
  const pool = all.filter(p =>
    ["WR","RB","TE","QB"].includes(p.pos) &&
    (p.games ?? 0) >= 3 &&
    (!p.status || ACTIVE.has(p.status))
  );

  // 3) precompute per-position percentile mappers
  const pctlPPRg = (pos:string)=>percentileWithinPos(pool, pos, x=>x.ppr_g ?? 0);
  const pctlXFPg = (pos:string)=>percentileWithinPos(pool, pos, x=>x.xfp_g ?? 0);
  const pctlSpike = (pos:string)=>percentileWithinPos(pool, pos, x=>x.spike90 ?? 0);
  const pctlTgtShare=(pos:string)=>percentileWithinPos(pool, pos, x=>x.tgtShare ?? 0);
  const pctlRushShare=(pos:string)=>percentileWithinPos(pool, pos, x=>x.rushShare ?? 0);
  const pctlRouteRate=(pos:string)=>percentileWithinPos(pool, pos, x=>x.routeRate ?? 0);

  // 4) scorer with rock-solid fallbacks
  const rows = await Promise.all(pool.map(async p=>{
    // Core: talent prefers xFPg, then PPRg
    const talentP = Math.max(pctlXFPg(p.pos)(p.xfp_g ?? 0), pctlPPRg(p.pos)(p.ppr_g ?? 0));

    // Role: shares/routes if present else lean on PPRg percentile (usage reflects)
    const roleSources = [
      pctlTgtShare(p.pos)(p.tgtShare ?? 0),
      p.pos==="RB" ? pctlRushShare(p.pos)(p.rushShare ?? 0) : pctlRouteRate(p.pos)(p.routeRate ?? 0),
    ].filter(Number.isFinite);
    const role = roleSources.length ? roleSources.reduce((a,b)=>a+b,0)/roleSources.length : pctlPPRg(p.pos)(p.ppr_g ?? 0);

    // Context: keep simple until OASIS live (median=50)
    const context = 50;

    // Recency: last6 PPRg percentile fallback ‚Üí PPRg
    const recency = Math.max(pctlPPRg(p.pos)(p.last6_ppr_g ?? 0), pctlPPRg(p.pos)(p.ppr_g ?? 0));

    // Spike: 90th pct game PPR percentile fallback ‚Üí recency
    const spike = Math.max(pctlSpike(p.pos)(p.spike90 ?? 0), recency);

    // Durability: mild age penalty + games bonus (bounded)
    const age = p.age ?? 26;
    const ageHit = p.pos==="RB" ? penalty(age, {peak:25, slope:2.2}) :
                    p.pos==="WR" ? penalty(age, {peak:26, slope:1.6}) :
                    p.pos==="TE" ? penalty(age, {peak:27, slope:1.2}) :
                                   penalty(age, {peak:28, slope:0.8});
    const durability = clamp(70 - ageHit + Math.min((p.games ?? 0)*1.5, 12)); // 0..100

    // Risk: small unless missing data / very old
    const missing = [
      p.tgtShare, p.rushShare, p.routeRate, p.last6_ppr_g, p.spike90, p.xfp_g
    ].filter(v=>v==null).length;
    const risk = clamp((ageHit*0.6) + (missing*3)); // higher = worse; subtracted below

    const score =
      talentP * cfg.talent +
      role    * cfg.role +
      context * cfg.context +
      durability * cfg.durability +
      recency * cfg.recency +
      spike   * cfg.spike -
      risk    * cfg.risk;

    return {
      ...p,
      score: Math.round(score*100)/100,
      tier: bucket(score, weights.tier_cutoffs),
      debug: { talentP, role, recency, spike, durability, risk }
    };
  }));

  rows.sort((a,b)=>b.score - a.score);
  return rows.map((r,i)=>({ rank: i+1, ...r }));
}

function penalty(age:number, {peak, slope}:{peak:number, slope:number}){
  // 0 at/before peak; linear penalty afterward
  return Math.max(0, (age - peak) * slope);
}
function bucket(score:number, cuts:number[]){
  for (let i=0;i<cuts.length;i++) if (score>=cuts[i]) return i+1;
  return cuts.length+1;
}

What this fixes
	‚Ä¢	If routes/share are missing, we still rank correctly via xFP_g/PPR_g percentiles.
	‚Ä¢	Elites (Lamb, Chase, Amon-Ra, Tyreek, Bijan, McCaffrey, Kelce/Andrews) float to the top because they dominate xFP/PPR.
	‚Ä¢	Depth vets stop clustering at ~45‚Äì48 with Tier 7.

‚∏ª

C) Strict inclusion filters (no ghosts)

Add to normalization or scorer:
	‚Ä¢	Exclude status in ["FA","RET","SUS","PUP","IR","NFI","DNR","HOLDOUT"].
	‚Ä¢	Require games >= 3 (configurable).
	‚Ä¢	Require at least one of xfp_g or ppr_g > 0.

const VALID = (p:NormalizedPlayer)=> (p.games??0) >= 3 && ((p.xfp_g??0) > 0 || (p.ppr_g??0) > 0);
const EXCLUDE = new Set(["FA","RET","SUS","PUP","IR","NFI","DNR","HOLDOUT"]);
const pool = all.filter(p=>["WR","RB","TE","QB"].includes(p.pos))
                .filter(p=>!p.status || (!EXCLUDE.has(p.status)))
                .filter(VALID);


‚∏ª

D) API: add audit to see why players are missing

server/routes/rankingsV3.ts

r.get("/api/rankings/deepseek/v3/audit", async (req,res)=>{
  const all = await getNormalizedPlayers();
  const byPos = (pos:string)=>all.filter(p=>p.pos===pos);
  const metrics = (pos:string)=>({
    total: byPos(pos).length,
    withFPTS: byPos(pos).filter(p=> (p.ppr_g??0)>0).length,
    withXFP:  byPos(pos).filter(p=> (p.xfp_g??0)>0).length,
    gte3:     byPos(pos).filter(p=> (p.games??0)>=3).length,
    active:   byPos(pos).filter(p=> !p.status || p.status==="Active").length
  });
  res.json({ WR:metrics("WR"), RB:metrics("RB"), TE:metrics("TE"), QB:metrics("QB") });
});

Run once: curl /api/rankings/deepseek/v3/audit ‚Üí confirms coverage.

‚∏ª

E) Minimal QA (copy/paste)
	‚Ä¢	Elites appear
	‚Ä¢	curl "/api/rankings/deepseek/v3?mode=dynasty&pos=WR" | jq '.data[0:15] | .[].name'
	‚Ä¢	Expect Lamb/Chase/Amon-Ra/Tyreek within top range.
	‚Ä¢	Depth vets drop
	‚Ä¢	None of Laquon Treadwell / Allen Hurns in top 50 unless insane usage.
	‚Ä¢	Missing ‚Üí present
	‚Ä¢	Count withFPTS ~ matches actives per pos (/audit).
	‚Ä¢	Tier sanity
	‚Ä¢	Top tiers not all ‚Äú7‚Äù.

‚∏ª

F) Config nudge (weights align with v3.1 bundle)

config/deepseek.v3.weights.json
	‚Ä¢	Dynasty: bump talent to reflect xFP now live.

{
  "version":"3.1.0",
  "mode_defaults":{
    "dynasty":{"talent":0.36,"role":0.16,"context":0.12,"durability":0.08,"recency":0.12,"spike":0.08,"risk":0.08},
    "redraft":{"talent":0.42,"role":0.20,"context":0.10,"durability":0.06,"recency":0.16,"spike":0.04,"risk":0.02}
  },
  "tier_cutoffs":[96,91,86,81,76,71],
  "guards":{"dry_run":true,"max_players":1500,"require_sleeper_sync_ok":true,"allow_enrichment":true}
}



‚∏ª

G) One-liner summary for the team

v3.1 hotpatch makes rankings production-reliable by deriving xFP/PPR per game from Sleeper weekly logs, using position percentiles for scoring when advanced metrics are missing, and excluding non-active/low-sample players. Result: elite producers surface; depth vets fall; coverage is near-complete; tiers normalize.

‚∏ª

If you want, I can also hand you a small test data printout shape (top-15 WR after patch) to eyeball, but the code above is the fast path to fix what you‚Äôre seeing right now.