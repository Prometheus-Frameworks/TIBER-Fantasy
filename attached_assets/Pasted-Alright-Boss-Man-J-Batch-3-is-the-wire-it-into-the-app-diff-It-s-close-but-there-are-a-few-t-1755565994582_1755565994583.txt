Alright, Boss Man J ‚Äî Batch #3 is the ‚Äúwire it into the app‚Äù diff. It‚Äôs close, but there are a few traps that‚Äôll cause flaky boots or break our response contract. Here‚Äôs the straight review, then a drop-in ingestion wrapper for Tiber.

---

# Quick Verdict

* ‚úÖ Feature flag present (`USE_SLEEPER_SYNC`) and router mount is straightforward.
* ‚ö†Ô∏è Health check timing + URL can race the server start and fail spuriously.
* ‚ö†Ô∏è Fallback `/api/sleeper/*` responses don‚Äôt include `meta` (contract break).
* ‚ö†Ô∏è Mixed logging (plain `console`) instead of structured JSON logs.
* ‚ö†Ô∏è `require('axios')` inside `setTimeout` ‚Äî keep imports consistent.
* üß© Importing `logInfo/logError` from the service couples app boot to a leaf module (brittle).

---

# Fixes to Apply

## 1) Mount with a clear base and keep router isolated

Your router already defines full paths (`/api/sleeper/...`), so either:

* `app.use(sleeperRouter)` (fine), or explicitly `app.use('/', sleeperRouter)` for clarity. Keep as-is.

## 2) Make the health check reliable

* Run it **after** the server is actually listening.
* Derive the base URL from `server.address()` or an env like `APP_BASE_URL`.
* Keep it optional; don‚Äôt crash the app if it fails.

### Pattern:

In your **server bootstrap** (where you call `app.listen()`):

```ts
const server = app.listen(PORT, () => {
  logInfo('server listening', { port: PORT });
  if (process.env.USE_SLEEPER_SYNC === 'true') {
    const base = process.env.APP_BASE_URL || `http://127.0.0.1:${PORT}`;
    setTimeout(async () => {
      try {
        const { default: axios } = await import('axios');
        const r = await axios.get(`${base}/api/sleeper/health`, { timeout: 4000 });
        logInfo('sleeper health ok', { status: r.data?.data?.status || 'unknown' });
      } catch (e:any) {
        logError('sleeper health failed', e);
      }
    }, 1500);
  }
});
```

*(Do this in the file that owns `listen()`, not in `app.ts`.)*

## 3) Return contract-correct fallback when disabled

Every response needs `meta`. Also return **503** with clear code.

```ts
function meta() { return { source: 'sleeper' as const, generatedAt: new Date().toISOString() }; }

app.all('/api/sleeper/*', (_req, res) => {
  res.status(503).json({
    ok: false,
    code: 'SERVICE_DISABLED',
    message: 'Sleeper Sync is currently disabled',
    details: 'Set USE_SLEEPER_SYNC=true to enable',
    meta: meta()
  });
});
```

(Optional) Provide a disabled health endpoint that still answers:

```ts
app.get('/api/sleeper/health', (_req, res) => {
  res.status(503).json({
    ok: false,
    code: 'SERVICE_DISABLED',
    message: 'Sleeper Sync is disabled',
    details: null,
    meta: meta()
  });
});
```

## 4) Structured JSON logs at app level

Don‚Äôt import `logInfo/logError` from the service (wrong layer). Define app-level logger:

```ts
function logInfo(msg: string, meta?: Record<string, any>) {
  console.log(JSON.stringify({ level:'info', src:'App', msg, ...(meta||{}) }));
}
function logError(msg: string, e:any, meta?: Record<string, any>) {
  console.error(JSON.stringify({ level:'error', src:'App', msg, error: e?.message||String(e), stack: e?.stack, ...(meta||{}) }));
}
```

Then:

```ts
if (USE_SLEEPER_SYNC) {
  logInfo('mounting sleeper routes');
  app.use(sleeperRouter);
} else {
  logInfo('sleeper sync disabled');
  // ‚Ä¶fallback routes above‚Ä¶
}
```

## 5) Keep imports clean

Use top-level `import axios from 'axios'` *or* dynamic `await import('axios')` (as shown), but don‚Äôt mix `require` in ESM/TS.

---

# Minimal Patched Snippet (for `app.ts`)

```ts
import sleeperRouter from './sleeperRoutes';

function logInfo(msg: string, meta?: Record<string, any>) {
  console.log(JSON.stringify({ level:'info', src:'App', msg, ...(meta||{}) }));
}
function logError(msg: string, e:any, meta?: Record<string, any>) {
  console.error(JSON.stringify({ level:'error', src:'App', msg, error: e?.message||String(e), stack: e?.stack, ...(meta||{}) }));
}
function meta() { return { source: 'sleeper' as const, generatedAt: new Date().toISOString() }; }

const USE_SLEEPER_SYNC = String(process.env.USE_SLEEPER_SYNC).toLowerCase() === 'true';

if (USE_SLEEPER_SYNC) {
  logInfo('mounting sleeper routes');
  app.use(sleeperRouter);
} else {
  logInfo('sleeper sync disabled');
  app.all('/api/sleeper/*', (_req, res) => {
    res.status(503).json({
      ok: false, code: 'SERVICE_DISABLED',
      message: 'Sleeper Sync is currently disabled',
      details: 'Set USE_SLEEPER_SYNC=true to enable',
      meta: meta()
    });
  });
  // Optional disabled health:
  app.get('/api/sleeper/health', (_req, res) => {
    res.status(503).json({ ok:false, code:'SERVICE_DISABLED', message:'Sleeper Sync is disabled', details:null, meta: meta() });
  });
}
```

And in your **server/bootstrap** (where `listen()` lives), add the health probe block from Fix #2.

---

# ‚úÖ Tiber Ingestion Wrapper (Batch #3)

Paste this to Tiber along with Batch #3:

> **Task:** Integrate the Sleeper router behind a feature flag and make the health check reliable. Do not rename existing endpoints.
>
> **Required changes:**
>
> 1. In `app.ts`, mount `sleeperRouter` when `USE_SLEEPER_SYNC === 'true'`. Log via structured JSON (`logInfo/logError` helpers at app level).
> 2. When disabled, respond on `/api/sleeper/*` with **HTTP 503** and a contract-correct body that includes `meta`. Also expose `/api/sleeper/health` returning 503 with the same error shape.
> 3. Move the health probe to the **server bootstrap** (file that calls `app.listen`). After the server is listening, compute `base = APP_BASE_URL || http://127.0.0.1:${PORT}` and `GET ${base}/api/sleeper/health` after \~1.5s. Log success/failure with structured JSON.
> 4. Use a single import style for axios (either top-level `import axios` or dynamic `await import('axios')` in the probe; prefer the latter to avoid loading axios during cold boot when disabled).
>
> **Deliverables:** Updated `app.ts` and server bootstrap file with the probe, plus a short diff summary.
> **Checks to run:**
>
> * `USE_SLEEPER_SYNC=false`:
>
>   * `curl -s -o /dev/null -w "%{http_code}\n" /api/sleeper/players` ‚Üí `503` and payload has `meta`.
> * `USE_SLEEPER_SYNC=true`:
>
>   * `curl -s /api/sleeper/health` ‚Üí `{ ok:true|false, meta:{...} }` (depending on upstream cache).
>   * App logs structured JSON for ‚Äúmounting sleeper routes‚Äù and probe result.

---

Shoot me Batch #4 when ready.
