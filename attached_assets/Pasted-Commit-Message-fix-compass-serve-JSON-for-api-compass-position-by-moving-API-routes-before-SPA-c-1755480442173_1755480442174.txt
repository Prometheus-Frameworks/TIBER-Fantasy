Commit Message
fix(compass): serve JSON for /api/compass/:position by moving API routes before SPA catch-all

- Register all /api routes (incl. /api/compass/:position) before any "*" handler
- Add WR compass route using PlayerCompassService
- Add debug logging + 400 validation for position/format
- Add dev test script + cURL examples

1) Route Order (critical)

Move the SPA catch-all after all API routes. Minimal diff:

 // server.ts (or index.ts)
-// âœ… existing order (WRONG)
-app.get('*', (req, res) => {
-  res.sendFile(path.join(publicDir, 'index.html'));
-});

-// API
-registerCompassRoutes(app);
-registerOtcConsensusRoutes(app);
-registerQwenPlayersRoutes(app);

+// Static (optional, scoped; do NOT catch /api)
+app.use('/static', express.static(publicDir));

+// API â€” ALL of them first
+registerCompassRoutes(app);
+registerOtcConsensusRoutes(app);
+registerQwenPlayersRoutes(app);

+// SPA catch-all LAST
+app.get('*', (req, res) => {
+  res.sendFile(path.join(publicDir, 'index.html'));
+});


If youâ€™re using Vite/CRA dev proxies, make sure they forward /api/** to the backend (examples below).

2) Compass Route (production-safe)

routes/compassRoutes.ts:

import { Express, Request, Response } from "express";

export const registerCompassRoutes = (app: Express) => {
  app.get("/api/compass/:position", async (req: Request, res: Response) => {
    try {
      console.log(`ðŸ§­ Route Hit: /api/compass/${req.params.position}`);

      const { playerCompassService } = await import("../services/playerCompassService");

      const position = String(req.params.position || "").toUpperCase();
      const format = (req.query.format as string) || "dynasty";
      const limit = Math.min(parseInt(String(req.query.limit || "50"), 10), 100);

      if (!["WR", "RB", "TE", "QB"].includes(position)) {
        return res.status(400).json({ ok: false, error: "Invalid position. Use WR, RB, TE, or QB" });
      }
      if (!["dynasty", "redraft"].includes(format)) {
        return res.status(400).json({ ok: false, error: 'Invalid format. Use "dynasty" or "redraft"' });
      }

      const players = await playerCompassService.getAllPlayersByPosition(position);
      const rankings = players
        .map((p: any) => {
          const score = playerCompassService.calculateCompass(p, format);
          return {
            id: `${position.toLowerCase()}-${p.playerId}`,
            name: p.playerName,
            team: p.team,
            pos: position,
            age: p.age,
            adp: p.adp,
            compass: {
              north: score.north,
              east: score.east,
              south: score.south,
              west: score.west,
              score: score.score,
            },
            tier: score.tier,
            insights: score.insights,
            format: score.format,
          };
        })
        .sort((a: any, b: any) => (b.compass.score ?? -1) - (a.compass.score ?? -1))
        .slice(0, limit);

      res.json({
        ok: true,
        position,
        format,
        data: rankings,
        meta: {
          count: rankings.length,
          source: "player_compass_service",
          algorithm: "4-directional_compass",
          ts: new Date().toISOString(),
          filters: { position, format, limit },
        },
      });
    } catch (err) {
      console.error("âŒ Player Compass API Error:", err);
      res.status(500).json({ ok: false, error: "Failed to generate Player Compass rankings" });
    }
  });
};


Register it before the catch-all:

import { registerCompassRoutes } from "@/routes/compassRoutes";
registerCompassRoutes(app);

3) Dev Proxy sanity (so requests donâ€™t hit the SPA)

Pick your stack:

Vite (vite.config.ts)

export default defineConfig({
  server: {
    proxy: {
      "/api": { target: "http://localhost:3001", changeOrigin: true },
    },
  },
});


CRA (package.json)

{ "proxy": "http://localhost:3001" }


Next.js (custom server or middleware)

If youâ€™re using a separate Express server, call it directly from the client (/api/...) via a rewrite:

// next.config.js
module.exports = {
  async rewrites() {
    return [{ source: "/api/:path*", destination: "http://localhost:3001/api/:path*" }];
  },
};

4) Tests (prove itâ€™s JSON, not HTML)

Smoke test

curl -i "http://localhost:3001/api/compass/WR?format=dynasty&limit=10"


Expect:

HTTP/1.1 200 OK

Content-Type: application/json

Body with { ok: true, position: "WR", data: [...] }

Bad position (400)

curl -i "http://localhost:3001/api/compass/K?format=dynasty"


Bad format (400)

curl -i "http://localhost:3001/api/compass/WR?format=arcade"


If you see HTML â†’ you still have order/proxy wrong. Fix order. Re-run.

5) Frontend quick check
// minimal check
const r = await fetch("/api/compass/WR?format=dynasty&limit=20");
const j = await r.json();
console.log(j.ok, j.data?.length, j.meta);

6) Optional safety net (makes debugging obvious)

Right before the SPA catch-all, add a 404 for unknown /api routes so they never hit HTML:

app.use("/api", (_req, res) => {
  res.status(404).json({ ok: false, error: "API route not found" });
});

// then the SPA catch-all
app.get("*", (req, res) => res.sendFile(path.join(publicDir, "index.html")));

TL;DR for Joe

Put all /api/** before the * handler.

Register Compass route early.

Hit it with curl. If you see HTML, your order/proxy is still borked.

You do this, Player Compass pillar stands. Then we can layer the fancy stuff (pagination, trigram search, radar charts) without the server handing us a damn index.html.