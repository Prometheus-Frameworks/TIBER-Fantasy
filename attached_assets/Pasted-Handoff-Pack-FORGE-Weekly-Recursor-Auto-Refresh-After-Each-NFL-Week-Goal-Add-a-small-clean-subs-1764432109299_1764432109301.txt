Handoff Pack: FORGE Weekly Recursor (Auto-Refresh After Each NFL Week)
Goal

Add a small, clean subsystem that:

Pulls new PBP / weekly data for the current season

Rebuilds:

team_offensive_context

team_defensive_context

team_environment

team_matchup_context

Logs what week/season it refreshed

Can be triggered:

Manually via an admin API route

Automatically via a Replit scheduled job that hits that route every Tuesday morning

No UI or cosmetic changes.

1️⃣ Add a Central “Current Season / Week” Config

Create server/config/forgeSeason.ts (or similar):

// server/config/forgeSeason.ts
export const FORGE_DEFAULT_SEASON = 2025;

// optional: simple helper if you want it
export function getForgeSeason(fromEnv = true): number {
  if (fromEnv && process.env.FORGE_SEASON) {
    return Number(process.env.FORGE_SEASON);
  }
  return FORGE_DEFAULT_SEASON;
}


We’ll use this as the default season everywhere in env/matchup pipelines.

2️⃣ Extract a Rebuild Service

Create server/services/forgeRebuildService.ts:

import { Pool } from 'pg';
import { getForgeSeason } from '../config/forgeSeason';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });

export interface ForgeRebuildOptions {
  season?: number;
  week?: number; // optional – if omitted, rebuild all weeks that exist for that season
}

export async function rebuildForgeContext(opts: ForgeRebuildOptions = {}) {
  const season = opts.season ?? getForgeSeason(false);

  console.log('[FORGE Rebuild] Starting rebuild...', { season, week: opts.week });

  // 1) Rebuild offensive & defensive context tables from PBP
  //    (these should already exist from your last agent task – just wrap them)

  await pool.query('BEGIN');

  try {
    // If your agent created SQL like this, just call it here:
    // 1a) offensive context
    await pool.query(
      `
      INSERT INTO team_offensive_context (season, week, team, pass_epa, rush_epa, run_sr, ...)
      SELECT ...
      FROM nflfastR_pbp
      WHERE season = $1
      ${opts.week ? 'AND week = $2' : ''}
      ON CONFLICT (season, week, team) DO UPDATE
      SET ...;
      `,
      opts.week ? [season, opts.week] : [season],
    );

    // 1b) defensive context
    await pool.query(
      `
      INSERT INTO team_defensive_context (season, week, defteam, pass_epa_allowed, ...)
      SELECT ...
      FROM nflfastR_pbp
      WHERE season = $1
      ${opts.week ? 'AND week = $2' : ''}
      ON CONFLICT (season, week, defteam) DO UPDATE
      SET ...;
      `,
      opts.week ? [season, opts.week] : [season],
    );

    // 2) Refresh env + matchup materialized views
    // (use CONCURRENTLY if they are big)
    await pool.query(`REFRESH MATERIALIZED VIEW CONCURRENTLY team_environment;`);
    await pool.query(`REFRESH MATERIALIZED VIEW CONCURRENTLY team_matchup_context;`);

    await pool.query('COMMIT');

    console.log('[FORGE Rebuild] Completed successfully', { season, week: opts.week });
  } catch (err) {
    await pool.query('ROLLBACK');
    console.error('[FORGE Rebuild] Failed', err);
    throw err;
  }
}


The agent should plug in the actual SELECT ... aggregation it already wrote for team_offensive_context / team_defensive_context. The important part is: one function, one place, that updates all FORGE context tables.

3️⃣ Admin API Endpoint to Trigger Rebuild

Add a locked-down admin route — e.g. server/routes/adminForge.ts:

import { Router, Request, Response } from 'express';
import { rebuildForgeContext } from '../services/forgeRebuildService';

const router = Router();

// simple shared-secret header; you can change the mechanism later
function isAuthorized(req: Request): boolean {
  const header = req.headers['x-forge-admin-key'];
  return header && header === process.env.FORGE_ADMIN_KEY;
}

router.post('/api/admin/forge/rebuild', async (req: Request, res: Response) => {
  if (!isAuthorized(req)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  const { season, week } = req.body || {};

  try {
    await rebuildForgeContext({
      season: season ? Number(season) : undefined,
      week: week ? Number(week) : undefined,
    });

    return res.json({
      ok: true,
      season: season ?? 'default',
      week: week ?? 'all',
    });
  } catch (err) {
    console.error('[FORGE Admin] Rebuild failed', err);
    return res.status(500).json({ error: 'FORGE rebuild failed' });
  }
});

export default router;


Wire it in server/index.ts or wherever routes are mounted:

import adminForgeRouter from './routes/adminForge';

app.use(adminForgeRouter);


Behaviour:

POST /api/admin/forge/rebuild with the right header:

If body empty → rebuild everything for default season (2025)

If { week: 12 } → rebuild just week 12 plus refresh views

4️⃣ Replit Scheduled Job (Tuesday Morning)

You’ll configure this part yourself in Replit, but the agent should make sure the endpoint exists and works.

Schedule a weekly job (e.g. Tuesday 6:00 AM ET) that:

Sends a POST to your app:

curl -X POST "https://<your-repl-url>.replit.dev/api/admin/forge/rebuild" \
  -H "Content-Type: application/json" \
  -H "x-forge-admin-key: $FORGE_ADMIN_KEY" \
  -d '{"season": 2025}'


That gives you:

Fresh offensive/defensive context

Fresh env & matchup scores

All re-normalized with the robust scaler

Without you needing to remember anything

5️⃣ Sanity Checks After It’s In

Have the agent verify:

Calling the admin route works locally:

curl -X POST http://localhost:5000/api/admin/forge/rebuild \
  -H "x-forge-admin-key: test-key" \
  -d '{"season": 2025, "week": 12}'


After the call, this returns updated data using 2025 / 12:

GET /api/forge/env-debug?team=KC

GET /api/forge/matchup-debug?defense=NYJ&position=WR

Rankings pages (/rankings/wr, /rankings/rb) reflect updated env/matchup context for week 12.