Boss Man J â€” this oneâ€™s on the frontend. Youâ€™re calling `fetch()` with a **string as the second arg**, so the browser is treating `"/api/start-sit/quick"` as the **HTTP method** ðŸ¤¦â€â™‚ï¸ â€¦which of course isnâ€™t valid.

### Why itâ€™s blowing up

You likely wrote something like:

```ts
fetch("/api/start-sit/quick", "POST"); // âŒ second arg must be an object
```

or passed the URL twice, or shoved a path into `method`.

### Fix (use a proper init object)

```ts
await fetch("/api/start-sit/quick", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    playerA: { id: "puka", position: "WR", team: "LAR", name: "Puka Nacua" },
    playerB: { id: "jaylen", position: "RB", team: "PIT", name: "Jaylen Warren" },
    week: 2
  })
});
```

### Safer React handler (copy/paste)

```ts
async function runStartSitQuick(payload: any) {
  try {
    const res = await fetch("/api/start-sit/quick", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err.detail || `HTTP ${res.status}`);
    }
    return await res.json();
  } catch (e) {
    console.error("start-sit/quick failed:", e);
    throw e;
  }
}
```

### If you never created `/api/start-sit/quick`

Either:

* change the frontend to hit the **existing** endpoint you already wired (`/api/start-sit` or `/api/start-sit/live`), **OR**
* add this tiny router that aliases to the live route:

```ts
// src/routes/startSitQuick.ts
import { Router } from "express";
import { buildStartSitInputs } from "../data/aggregator/startSitAggregator";
import { startSit, defaultConfig } from "../modules/startSitEngine";

const router = Router();

router.post("/start-sit/quick", async (req, res) => {
  try {
    const { playerA, playerB, week, config } = req.body ?? {};
    if (!playerA || !playerB) return res.status(400).json({ error: "playerA/playerB required" });

    const { a, b } = await buildStartSitInputs({ playerA, playerB, week });
    const result = startSit(a, b, { ...defaultConfig, ...(config || {}) });

    res.json({
      verdict: result.verdict,
      margin: result.margin,
      summary: result.summary,
      playerA: { name: a.name, position: a.position, breakdown: result.a },
      playerB: { name: b.name, position: b.position, breakdown: result.b },
    });
  } catch (err: any) {
    console.error("[/start-sit/quick]", err);
    res.status(400).json({ error: "bad_input_or_internal", detail: String(err?.message || err) });
  }
});

export default router;
```

Mount it:

```ts
// src/server.ts
import startSitQuick from "./routes/startSitQuick";
app.use("/api", startSitQuick);
```

### Quick sanity checks (worth 30s)

* Middleware present?

  ```ts
  app.use(express.json({ limit: "1mb" }));
  app.use(cors());
  ```
* Frontend hitting the right origin? If server is on 3000 and UI on another port, use the full URL or a proxy.
* Test with curl:

  ```bash
  curl -X POST http://localhost:3000/api/start-sit/quick \
    -H "Content-Type: application/json" \
    -d '{"playerA":{"id":"puka","position":"WR","team":"LAR"}, "playerB":{"id":"warren","position":"RB","team":"PIT"}, "week":2}'
  ```

Fix the `fetch` signature (and/or route), and that red toast dies instantly.
