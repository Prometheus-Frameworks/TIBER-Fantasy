1) src/modules/startSitEngine.ts
// src/modules/startSitEngine.ts
// v1.0 — Start/Sit scoring engine with explainability

export type Position = "QB" | "RB" | "WR" | "TE" | "DST" | "K";

export interface PlayerInput {
  id: string;
  name: string;
  team?: string;
  position: Position;

  // --- Core Inputs ---
  // Projections (baseline expected outcome)
  projPoints?: number;            // e.g., 0-40 typical
  projFloor?: number | null;      // optional
  projCeiling?: number | null;    // optional

  // Usage / Role
  snapPct?: number;               // 0-100
  routeParticipation?: number;    // 0-100 (WR/TE/RB)
  targetShare?: number;           // 0-100 (WR/TE/RB)
  weightedTouches?: number;       // RB: targets*1.5 + carries (approx)
  rzTouches?: number;             // last 3 weeks etc.
  insideTenTouches?: number;      // optional

  // Matchup / Environment
  defRankVsPos?: number;          // 1 (hard) ... 32 (easy) — inverted in scoring
  oasisMatchupScore?: number;     // 0-100 from your OASIS
  impliedTeamTotal?: number;      // Vegas points 10-40 typical
  olHealthIndex?: number;         // 0-100 (QB/RB helpful)
  weatherImpact?: number;         // -1 to +1 (negative bad weather, positive dome/ideal)

  // Volatility / Trust
  stdevLast5?: number;            // standard deviation of last 5 weeks fantasy points
  injuryTag?: "OUT" | "D" | "Q" | "P" | null;
  committeeRisk?: number;         // 0-100 (higher = more risk)
  depthChartThreats?: number;     // 0-100 (higher = more target cannibalization)

  // Market / News
  newsHeat?: number;              // 0-100 beat/role signal (manual or NLP)
  ecrDelta?: number;              // Expert Rank delta vs market (pos sentiment = upside)
}

export interface FactorWeights {
  projections: number;   // default 0.45
  usage: number;         // default 0.25
  matchup: number;       // default 0.15
  volatility: number;    // default 0.10
  news: number;          // default 0.05
}

export interface PositionWeightsMap {
  [pos: string]: FactorWeights;
}

export interface StartSitConfig {
  // global factor weights by position (override as needed)
  weights: PositionWeightsMap;

  // per-factor subweight knobs (stay in 0-1; they’ll be normalized internally)
  usageSub: {
    snap: number;
    routes: number;
    tShare: number;
    wTouches: number;
    rz: number;
    i10: number;
  };
  matchupSub: {
    defRank: number;
    oasis: number;
    implied: number;
    ol: number;
    weather: number;
  };
  volatilitySub: {
    stdev: number;
    injury: number;
    committee: number;
    threats: number;
  };
  newsSub: {
    heat: number;
    ecrDelta: number;
  };

  // verdict thresholds (difference between players’ total score)
  clearMargin: number;   // >= -> CLEAR START
  leanMargin: number;    // >= -> LEAN START; else toss-up
}

export interface FactorBreakdown {
  projections: number;
  usage: number;
  matchup: number;
  volatility: number;
  news: number;
  total: number;
  reasons: string[];
}

export interface StartSitResult {
  a: FactorBreakdown;
  b: FactorBreakdown;
  verdict: "START_A" | "START_B" | "LEAN_A" | "LEAN_B" | "TOSS_UP";
  margin: number; // abs(a.total - b.total)
  summary: string;
}

// ---------- defaults ----------
export const defaultWeightsByPos: PositionWeightsMap = {
  QB: { projections: 0.45, usage: 0.20, matchup: 0.20, volatility: 0.10, news: 0.05 },
  RB: { projections: 0.45, usage: 0.30, matchup: 0.15, volatility: 0.07, news: 0.03 },
  WR: { projections: 0.45, usage: 0.25, matchup: 0.15, volatility: 0.10, news: 0.05 },
  TE: { projections: 0.45, usage: 0.25, matchup: 0.15, volatility: 0.10, news: 0.05 },
  DST:{ projections: 0.55, usage: 0.00, matchup: 0.35, volatility: 0.05, news: 0.05 },
  K:  { projections: 0.55, usage: 0.00, matchup: 0.35, volatility: 0.05, news: 0.05 },
};

export const defaultConfig: StartSitConfig = {
  weights: defaultWeightsByPos,
  usageSub:   { snap: 0.25, routes: 0.20, tShare: 0.25, wTouches: 0.20, rz: 0.07, i10: 0.03 },
  matchupSub: { defRank: 0.25, oasis: 0.30, implied: 0.25, ol: 0.15, weather: 0.05 },
  volatilitySub: { stdev: 0.40, injury: 0.35, committee: 0.15, threats: 0.10 },
  newsSub: { heat: 0.70, ecrDelta: 0.30 },
  clearMargin: 8,   // clear start if >= 8 pts apart
  leanMargin: 3,    // lean start if >= 3 pts apart
};

// ---------- helpers ----------
const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v));
const nz = (v: number | undefined | null, fallback = 0) => (v == null ? fallback : v);

// Min-max scalers (rough NFL ranges baked in; tune later with your live distros)
const scaleProj = (p?: number) => clamp(((nz(p) - 0) / 35) * 100, 0, 100);              // 0-35 pts
const scaleImplied = (v?: number) => clamp(((nz(v) - 12) / 28) * 100, 0, 100);          // 12-40 pts team total
const scaleDefRank = (rank?: number) => clamp(((nz(rank, 32) - 1) / 31) * 100, 0, 100); // 1 hard -> 0, 32 easy ->100
const scaleVolStdev = (s?: number) => 100 - clamp((nz(s) / 12) * 100, 0, 100);          // less stdev better
const penaltyFromInjury = (t: PlayerInput["injuryTag"]) => {
  if (t === "OUT") return 0;
  if (t === "D") return 25;
  if (t === "Q") return 60;
  if (t === "P") return 85;
  return 100;
};
const invertRisk = (x?: number) => 100 - clamp(nz(x), 0, 100);

// ---------- core scoring ----------
function scoreProjections(p: PlayerInput, reasons: string[]) {
  const base = scaleProj(p.projPoints);
  const floor = p.projFloor != null ? scaleProj(p.projFloor) : null;
  const ceil  = p.projCeiling != null ? scaleProj(p.projCeiling) : null;

  let bonus = 0;
  if (ceil != null && floor != null) {
    const spread = ceil - floor; // range confidence
    // small bonus if high base and reasonable spread
    if (base >= 60 && spread <= 25) bonus += 3;
  }
  if (bonus) reasons.push(`Projection bonus +${bonus.toFixed(1)}`);

  reasons.push(`Proj ${p.projPoints ?? 0} → ${base.toFixed(1)}`);
  return clamp(base + bonus, 0, 100);
}

function scoreUsage(p: PlayerInput, cfg: StartSitConfig, reasons: string[]) {
  const u = cfg.usageSub;
  const totalSub = u.snap + u.routes + u.tShare + u.wTouches + u.rz + u.i10;

  const snap = clamp(nz(p.snapPct), 0, 100);
  const routes = clamp(nz(p.routeParticipation), 0, 100);
  const tShare = clamp(nz(p.targetShare), 0, 100);

  // ballpark scales for RB volume; safe for WR (weightedTouches can be 0)
  const wTouches = clamp((nz(p.weightedTouches) / 25) * 100, 0, 100);
  const rz = clamp((nz(p.rzTouches) / 6) * 100, 0, 100);
  const i10 = clamp((nz(p.insideTenTouches) / 3) * 100, 0, 100);

  const score = (
    snap * (u.snap / totalSub) +
    routes * (u.routes / totalSub) +
    tShare * (u.tShare / totalSub) +
    wTouches * (u.wTouches / totalSub) +
    rz * (u.rz / totalSub) +
    i10 * (u.i10 / totalSub)
  );

  reasons.push(
    `Usage: snap ${snap.toFixed(0)} | routes ${routes.toFixed(0)} | tShare ${tShare.toFixed(0)} | wTouches ${wTouches.toFixed(0)} | RZ ${rz.toFixed(0)} | i10 ${i10.toFixed(0)}`
  );
  return clamp(score, 0, 100);
}

function scoreMatchup(p: PlayerInput, cfg: StartSitConfig, reasons: string[]) {
  const m = cfg.matchupSub;
  const totalSub = m.defRank + m.oasis + m.implied + m.ol + m.weather;

  const def = scaleDefRank(p.defRankVsPos);
  const oasis = clamp(nz(p.oasisMatchupScore), 0, 100);
  const implied = scaleImplied(p.impliedTeamTotal);
  const ol = clamp(nz(p.olHealthIndex), 0, 100);
  const weatherAdj = clamp(((nz(p.weatherImpact) + 1) / 2) * 100, 0, 100); // -1..+1 → 0..100

  const score = (
    def * (m.defRank / totalSub) +
    oasis * (m.oasis / totalSub) +
    implied * (m.implied / totalSub) +
    ol * (m.ol / totalSub) +
    weatherAdj * (m.weather / totalSub)
  );

  reasons.push(
    `Matchup: defRankAdj ${def.toFixed(0)} | OASIS ${oasis.toFixed(0)} | implied ${implied.toFixed(0)} | OL ${ol.toFixed(0)} | weather ${weatherAdj.toFixed(0)}`
  );
  return clamp(score, 0, 100);
}

function scoreVolatility(p: PlayerInput, cfg: StartSitConfig, reasons: string[]) {
  const v = cfg.volatilitySub;
  const totalSub = v.stdev + v.injury + v.committee + v.threats;

  const stdev = scaleVolStdev(p.stdevLast5);
  const injury = penaltyFromInjury(p.injuryTag);
  const committee = invertRisk(p.committeeRisk);
  const threats = invertRisk(p.depthChartThreats);

  const score = (
    stdev * (v.stdev / totalSub) +
    injury * (v.injury / totalSub) +
    committee * (v.committee / totalSub) +
    threats * (v.threats / totalSub)
  );

  reasons.push(
    `Trust: stdevAdj ${stdev.toFixed(0)} | injuryAdj ${injury.toFixed(0)} | committeeAdj ${committee.toFixed(0)} | threatsAdj ${threats.toFixed(0)}`
  );
  return clamp(score, 0, 100);
}

function scoreNews(p: PlayerInput, cfg: StartSitConfig, reasons: string[]) {
  const n = cfg.newsSub;
  const totalSub = n.heat + n.ecrDelta;

  const heat = clamp(nz(p.newsHeat), 0, 100);
  // ECR delta: map roughly -15..+15 → 0..100
  const ecr = clamp(((nz(p.ecrDelta) + 15) / 30) * 100, 0, 100);

  const score = (
    heat * (n.heat / totalSub) +
    ecr * (n.ecrDelta / totalSub)
  );

  reasons.push(`News: heat ${heat.toFixed(0)} | ecrAdj ${ecr.toFixed(0)}`);
  return clamp(score, 0, 100);
}

export function scorePlayer(p: PlayerInput, cfg: StartSitConfig = defaultConfig): FactorBreakdown {
  const reasons: string[] = [];
  const pos = p.position in cfg.weights ? p.position : "WR";
  const w = cfg.weights[pos];

  const proj = scoreProjections(p, reasons);
  const usage = scoreUsage(p, cfg, reasons);
  const matchup = scoreMatchup(p, cfg, reasons);
  const vol = scoreVolatility(p, cfg, reasons);
  const news = scoreNews(p, cfg, reasons);

  const total =
    proj * w.projections +
    usage * w.usage +
    matchup * w.matchup +
    vol * w.volatility +
    news * w.news;

  return {
    projections: proj,
    usage,
    matchup,
    volatility: vol,
    news,
    total: Number(total.toFixed(2)),
    reasons,
  };
}

export function startSit(
  a: PlayerInput,
  b: PlayerInput,
  cfg: StartSitConfig = defaultConfig
): StartSitResult {
  const sa = scorePlayer(a, cfg);
  const sb = scorePlayer(b, cfg);

  const diff = Number((sa.total - sb.total).toFixed(2));
  const margin = Math.abs(diff);

  let verdict: StartSitResult["verdict"] = "TOSS_UP";
  if (diff >= cfg.clearMargin) verdict = "START_A";
  else if (diff <= -cfg.clearMargin) verdict = "START_B";
  else if (diff >= cfg.leanMargin) verdict = "LEAN_A";
  else if (diff <= -cfg.leanMargin) verdict = "LEAN_B";
  else verdict = "TOSS_UP";

  const leader = diff >= 0 ? a : b;
  const summary =
    verdict === "TOSS_UP"
      ? `Toss-up: ${a.name} vs ${b.name}. Check matchup notes & roster needs (ceiling vs floor).`
      : `${leader.name} leads by ${margin.toFixed(1)} pts — verdict: ${verdict.replace("_", " ")}`;

  return { a: sa, b: sb, verdict, margin, summary };
}

2) src/routes/startSitRoutes.ts
// src/routes/startSitRoutes.ts
import { Router, Request, Response } from "express";
import { StartSitConfig, defaultConfig, PlayerInput, startSit } from "../modules/startSitEngine";

const router = Router();

/**
 * POST /api/start-sit
 * body: {
 *   playerA: PlayerInput,
 *   playerB: PlayerInput,
 *   config?: Partial<StartSitConfig>   // optional overrides
 * }
 */
router.post("/start-sit", (req: Request, res: Response) => {
  try {
    const { playerA, playerB, config } = req.body as {
      playerA: PlayerInput;
      playerB: PlayerInput;
      config?: Partial<StartSitConfig>;
    };

    if (!playerA || !playerB) {
      return res.status(400).json({ error: "playerA and playerB are required" });
    }

    // shallow merge for quick overrides; for deep overrides, add a small merge util
    const mergedConfig: StartSitConfig = {
      ...defaultConfig,
      ...(config as any),
      weights: { ...defaultConfig.weights, ...(config?.weights || {}) },
      usageSub: { ...defaultConfig.usageSub, ...(config?.usageSub || {}) },
      matchupSub: { ...defaultConfig.matchupSub, ...(config?.matchupSub || {}) },
      volatilitySub: { ...defaultConfig.volatilitySub, ...(config?.volatilitySub || {}) },
      newsSub: { ...defaultConfig.newsSub, ...(config?.newsSub || {}) },
    };

    const result = startSit(playerA, playerB, mergedConfig);

    return res.json({
      verdict: result.verdict,
      margin: result.margin,
      summary: result.summary,
      playerA: {
        name: playerA.name,
        position: playerA.position,
        breakdown: result.a,
      },
      playerB: {
        name: playerB.name,
        position: playerB.position,
        breakdown: result.b,
      },
    });
  } catch (err: any) {
    console.error("[start-sit] error", err);
    return res.status(500).json({ error: "internal_error", detail: String(err?.message || err) });
  }
});

export default router;

3) Wire it up (server)

Add this to your Express bootstrap (where you mount routes):

// src/server.ts (or wherever you configure Express)
import startSitRoutes from "./routes/startSitRoutes";

// ...
app.use("/api", startSitRoutes);

4) Quick cURL test
curl -X POST http://localhost:3000/api/start-sit \
  -H "Content-Type: application/json" \
  -d '{
    "playerA": {
      "id": "p1",
      "name": "Player Alpha",
      "position": "WR",
      "projPoints": 15.8,
      "snapPct": 88,
      "routeParticipation": 92,
      "targetShare": 27,
      "weightedTouches": 0,
      "rzTouches": 3,
      "insideTenTouches": 1,
      "defRankVsPos": 26,
      "oasisMatchupScore": 72,
      "impliedTeamTotal": 25.5,
      "olHealthIndex": 78,
      "weatherImpact": 0.2,
      "stdevLast5": 7.1,
      "injuryTag": null,
      "committeeRisk": 10,
      "depthChartThreats": 35,
      "newsHeat": 62,
      "ecrDelta": 3
    },
    "playerB": {
      "id": "p2",
      "name": "Player Bravo",
      "position": "WR",
      "projPoints": 14.1,
      "snapPct": 73,
      "routeParticipation": 78,
      "targetShare": 21,
      "weightedTouches": 0,
      "rzTouches": 1,
      "insideTenTouches": 0,
      "defRankVsPos": 8,
      "oasisMatchupScore": 48,
      "impliedTeamTotal": 20.5,
      "olHealthIndex": 66,
      "weatherImpact": -0.3,
      "stdevLast5": 10.4,
      "injuryTag": "Q",
      "committeeRisk": 25,
      "depthChartThreats": 55,
      "newsHeat": 40,
      "ecrDelta": -2
    }
  }'


You’ll get a verdict + breakdown + human-readable reasons.