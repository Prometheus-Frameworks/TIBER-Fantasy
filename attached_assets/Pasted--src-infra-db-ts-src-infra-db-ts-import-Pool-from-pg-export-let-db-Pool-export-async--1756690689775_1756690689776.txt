/src/infra/db.ts
// /src/infra/db.ts
import { Pool } from 'pg';

export let db: Pool;

export async function initDb() {
  if (db) return db;
  const url = process.env.DATABASE_URL;
  if (!url) throw new Error('DATABASE_URL not set');
  db = new Pool({ connectionString: url, max: 10 });
  // basic health check
  await db.query('select 1');
  return db;
}

// Helper: typed query
export async function q<T = any>(text: string, params?: any[]): Promise<{ rows: T[] }> {
  if (!db) await initDb();
  // @ts-ignore
  return db.query(text, params);
}

/src/infra/logger.ts
// /src/infra/logger.ts
type Lvl = 'debug' | 'info' | 'warn' | 'error';

const LEVEL_ORDER: Record<Lvl, number> = { debug: 10, info: 20, warn: 30, error: 40 };
const CURRENT = (process.env.LOG_LEVEL as Lvl) || 'info';

function log(lvl: Lvl, msg: string, meta?: Record<string, any>) {
  if (LEVEL_ORDER[lvl] < LEVEL_ORDER[CURRENT]) return;
  const line = {
    t: new Date().toISOString(),
    lvl,
    msg,
    ...meta,
  };
  // eslint-disable-next-line no-console
  console[lvl === 'error' ? 'error' : lvl === 'warn' ? 'warn' : 'log'](JSON.stringify(line));
}

export const logger = {
  debug: (m: string, meta?: any) => log('debug', m, meta),
  info:  (m: string, meta?: any) => log('info', m, meta),
  warn:  (m: string, meta?: any) => log('warn', m, meta),
  error: (m: string, meta?: any) => log('error', m, meta),
};

/src/jobs/nightlyRecalc.ts (seeded, runnable)

This version:

Pulls active players from players

Loads component scores via loaders.ts (stubs are fine to start)

Computes power_score with position weights

Clamps to last week (hysteresis)

Upserts player_week_facts

Materializes power_ranks (OVERALL + by position)

Computes delta_w vs prior week

// /src/jobs/nightlyRecalc.ts
import { q, initDb } from '../infra/db.js';
import { logger } from '../infra/logger.js';
import { computePowerScore } from '../core/scoring.js';
import { clampDelta } from '../core/smoothing.js';
import type { PlayerFacts } from '../core/types.js';
import { loadAvailability, loadEnvironment, loadMarketAnchor, loadTalent, loadUsageBundle } from '../data/loaders.js';

function getSeasonWeek(d: Date = new Date()) {
  // Adjust if you maintain your own season/week calendar; seed logic for now.
  // NFL Week 1 ~ early September; we’ll map ISO week to season placeholder.
  const season = d.getUTCFullYear();
  // naive: use ISO week % 18 range; replace with your real calendar later.
  const jan1 = new Date(Date.UTC(season, 0, 1));
  const diff = Math.floor((+d - +jan1) / 86400000);
  const isoWeek = Math.ceil((diff + jan1.getUTCDay() + 1) / 7);
  const week = Math.min(Math.max(1, isoWeek % 18 || 1), 18);
  return { season, week };
}

async function getPlayers() {
  const { rows } = await q<{ player_id: string; name: string; team: string; position: 'QB'|'RB'|'WR'|'TE' }>(
    `select player_id, name, team, position from players where position in ('QB','RB','WR','TE')`
  );
  return rows;
}

async function getLastWeekScore(player_id: string, season: number, week: number) {
  const { rows } = await q<{ power_score: number }>(
    `select power_score from player_week_facts where player_id=$1 and season=$2 and week=$3`,
    [player_id, season, week - 1]
  );
  return rows[0]?.power_score as number | undefined;
}

async function upsertFacts(f: PlayerFacts) {
  await q(
    `insert into player_week_facts
     (player_id, season, week, usage_now, talent, environment, availability, market_anchor,
      power_score, confidence, flags, last_update)
     values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11, now())
     on conflict (player_id, season, week)
     do update set usage_now=$4, talent=$5, environment=$6, availability=$7, market_anchor=$8,
       power_score=$9, confidence=$10, flags=$11, last_update=now()`,
    [
      f.player_id, f.season, f.week,
      f.usage_now, f.talent, f.environment, f.availability, f.market_anchor,
      f.power_score, f.confidence, f.flags
    ]
  );
}

async function materializeRanks(season: number, week: number) {
  // OVERALL + by position
  const sets = [
    { key: 'OVERALL', where: `position in ('QB','RB','WR','TE')` },
    { key: 'QB', where: `position='QB'` },
    { key: 'RB', where: `position='RB'` },
    { key: 'WR', where: `position='WR'` },
    { key: 'TE', where: `position='TE'` },
  ];

  for (const s of sets) {
    const { rows } = await q<{ player_id: string; power_score: number }>(
      `select f.player_id, f.power_score
       from player_week_facts f
       join players p on p.player_id=f.player_id
       where f.season=$1 and f.week=$2 and ${s.where}
       order by f.power_score desc nulls last
       limit 500`,
      [season, week]
    );

    // Remove existing rows for this slice
    await q(`delete from power_ranks where season=$1 and week=$2 and ranking_type=$3`, [season, week, s.key]);

    // Insert with rank & delta_w
    let rank = 1;
    for (const r of rows) {
      // delta vs last week rank: compute previous rank quickly
      const prev = await q<{ rank: number }>(
        `select rank from power_ranks where season=$1 and week=$2 and ranking_type=$3 and player_id=$4`,
        [season, week - 1, s.key, r.player_id]
      );
      const prevRank = prev.rows[0]?.rank;
      const delta_w = typeof prevRank === 'number' ? prevRank - rank : 0;

      await q(
        `insert into power_ranks (season, week, ranking_type, rank, player_id, power_score, delta_w, generated_at)
         values ($1,$2,$3,$4,$5,$6,$7, now())`,
        [season, week, s.key, rank, r.player_id, r.power_score, delta_w]
      );
      rank++;
    }
  }
}

async function main() {
  await initDb();
  const { season, week } = getSeasonWeek();
  logger.info('nightlyRecalc: start', { season, week });

  const players = await getPlayers();
  logger.info('players.count', { n: players.length });

  for (const p of players) {
    try {
      // Load component bundles (0–100 scale). Stubs are fine to boot.
      const [usage_now, talent, environment, availability, market_anchor] = await Promise.all([
        loadUsageBundle(p.player_id, season, week),
        loadTalent(p.player_id),
        loadEnvironment(p.team),
        loadAvailability(p.player_id),
        loadMarketAnchor(p.player_id),
      ]);

      // Compute score
      const flags: string[] = []; // set flags here if needed
      const confidence = 0.7;     // seed; can compute from sample size later

      const nextRaw = computePowerScore({
        player_id: p.player_id,
        season, week,
        position: p.position,
        usage_now, talent, environment, availability, market_anchor,
        flags, confidence
      } as PlayerFacts);

      // clamp (hysteresis) vs last week
      const last = await getLastWeekScore(p.player_id, season, week);
      const power_score = clampDelta(last, nextRaw, flags);

      await upsertFacts({
        player_id: p.player_id,
        season, week,
        position: p.position,
        usage_now, talent, environment, availability, market_anchor,
        power_score, confidence, flags
      } as PlayerFacts);

    } catch (e: any) {
      logger.error('recalc.player.error', { player_id: p.player_id, err: e?.message });
    }
  }

  await materializeRanks(season, week);
  logger.info('nightlyRecalc: done', { season, week });
}

if (import.meta.url === `file://${process.argv[1]}`) {
  // run if executed directly
  main().catch(e => {
    logger.error('nightlyRecalc: fatal', { err: e?.message });
    process.exit(1);
  });
}

/src/jobs/eventRecalc.ts (minimal worker)
// /src/jobs/eventRecalc.ts
import { initDb, q } from '../infra/db.js';
import { logger } from '../infra/logger.js';
import { computePowerScore } from '../core/scoring.js';
import type { PlayerFacts } from '../core/types.js';
import { loadAvailability, loadEnvironment, loadMarketAnchor, loadTalent, loadUsageBundle } from '../data/loaders.js';

async function impactPlayers(scope: any) {
  // Expand impact by scope
  if (scope.player_id) return [scope.player_id];
  if (scope.team) {
    const { rows } = await q<{ player_id: string }>(
      `select player_id from players where team=$1 and position in ('RB','WR','TE')`,
      [scope.team]
    );
    return rows.map(r => r.player_id);
  }
  return [];
}

async function lastFacts(player_id: string, season: number, week: number) {
  const { rows } = await q<any>(
    `select power_score from player_week_facts where player_id=$1 and season=$2 and week=$3`,
    [player_id, season, week]
  );
  return rows[0];
}

async function upsertFacts(f: PlayerFacts) {
  await q(
    `insert into player_week_facts
     (player_id, season, week, usage_now, talent, environment, availability, market_anchor,
      power_score, confidence, flags, last_update)
     values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11, now())
     on conflict (player_id, season, week)
     do update set usage_now=$4, talent=$5, environment=$6, availability=$7, market_anchor=$8,
       power_score=$9, confidence=$10, flags=$11, last_update=now()`,
    [
      f.player_id, f.season, f.week,
      f.usage_now, f.talent, f.environment, f.availability, f.market_anchor,
      f.power_score, f.confidence, f.flags
    ]
  );
}

async function materializeSliceFor(season: number, week: number, player_ids: string[]) {
  // Quick-and-dirty: rebuild ranks for affected positions + overall
  // (Optimization later: local reinsert.)
  const { rows: positions } = await q<{ position: string }>(
    `select distinct position from players where player_id = any($1)`, [player_ids]
  );
  const posList = positions.map(p => p.position);
  const slices = ['OVERALL', ...posList];

  for (const key of slices) {
    const where = key === 'OVERALL' ? `position in ('QB','RB','WR','TE')` : `position='${key}'`;
    const { rows } = await q<{ player_id: string; power_score: number }>(
      `select f.player_id, f.power_score
       from player_week_facts f
       join players p on p.player_id=f.player_id
       where f.season=$1 and f.week=$2 and ${where}
       order by f.power_score desc nulls last
       limit 500`,
      [season, week]
    );
    await q(`delete from power_ranks where season=$1 and week=$2 and ranking_type=$3`, [season, week, key]);
    let rank = 1;
    for (const r of rows) {
      const prev = await q<{ rank: number }>(
        `select rank from power_ranks where season=$1 and week=$2 and ranking_type=$3 and player_id=$4`,
        [season, week - 1, key, r.player_id]
      );
      const prevRank = prev.rows[0]?.rank;
      const delta_w = typeof prevRank === 'number' ? prevRank - rank : 0;
      await q(
        `insert into power_ranks (season, week, ranking_type, rank, player_id, power_score, delta_w, generated_at)
         values ($1,$2,$3,$4,$5,$6,$7, now())`,
        [season, week, key, rank, r.player_id, r.power_score, delta_w]
      );
      rank++;
    }
  }
}

function getSeasonWeek(d: Date = new Date()) {
  const season = d.getUTCFullYear();
  const week = 1; // Replace with your calendar if needed
  return { season, week };
}

async function processOnce() {
  const evt = await q<any>(`select * from events_queue where processed=false order by created_at asc limit 1`);
  const event = evt.rows[0];
  if (!event) return false;

  const { season, week } = getSeasonWeek();
  logger.info('event.start', { id: event.id, type: event.event_type });

  const affected = await impactPlayers(event.scope);
  for (const player_id of affected) {
    // bypass clamp for events
    const [usage_now, talent, environment, availability, market_anchor] = await Promise.all([
      loadUsageBundle(player_id, season, week),
      loadTalent(player_id),
      loadEnvironment(event.scope.team || ''), // safe default
      loadAvailability(player_id),
      loadMarketAnchor(player_id),
    ]);

    const positionRow = await q<{ position: 'QB'|'RB'|'WR'|'TE' }>(`select position from players where player_id=$1`, [player_id]);
    const position = positionRow.rows[0]?.position || 'WR';

    const power_score = computePowerScore({
      player_id, season, week, position,
      usage_now, talent, environment, availability, market_anchor,
      flags: [event.event_type], confidence: 0.7
    } as PlayerFacts);

    await upsertFacts({
      player_id, season, week, position,
      usage_now, talent, environment, availability, market_anchor,
      power_score, confidence: 0.7, flags: [event.event_type]
    } as PlayerFacts);
  }

  await q(`update events_queue set processed=true where id=$1`, [event.id]);
  await materializeSliceFor(season, week, affected);
  logger.info('event.done', { id: event.id, type: event.event_type, affected: affected.length });
  return true;
}

async function main() {
  await initDb();
  logger.info('eventRecalc: worker online');
  // poll loop
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const worked = await processOnce();
    await new Promise(r => setTimeout(r, worked ? 200 : 1000 * 60)); // faster if we had work
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(e => {
    logger.error('eventRecalc: fatal', { err: e?.message });
    process.exit(1);
  });
}

/src/server.ts (tiny fix to ensure db init before routes)
// /src/server.ts
import Fastify from 'fastify';
import routes from './api/powerRoutes.js';
import { initDb } from './infra/db.js';
import { logger } from './infra/logger.js';

async function main() {
  await initDb();
  const app = Fastify({ logger: true });
  await app.register(routes);
  const port = Number(process.env.PORT || 8084);
  await app.listen({ port, host: '0.0.0.0' });
  logger.info('server.listening', { port });
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(e => {
    console.error(e);
    process.exit(1);
  });
}

Quick README note for Tiber (drop in)

Run schema:

psql "$DATABASE_URL" -f sql/001_schema.sql
psql "$DATABASE_URL" -f sql/002_indexes.sql


Dev run:

npm i
npm run dev


Nightly recompute (manual):

npm run recalc:nightly


Event worker:

npm run recalc:events

Next hookups (team)

Tiber: Wire loaders.ts to DeepSeek/OASIS/actives.

Grok: Add validation.ts backtest (Spearman + top-12 hit rate).

Frontend: Start consuming /api/power/OVERALL?season=2025&week=1 with mock data; hook up sparklines and Δ badges.

This gives you a runnable skeleton that produces ranks the moment loaders return nonzero values. If you want me to also drop a mock loaders.ts (that returns deterministic scores so UI can render immediately), say the word and I’ll toss it in.