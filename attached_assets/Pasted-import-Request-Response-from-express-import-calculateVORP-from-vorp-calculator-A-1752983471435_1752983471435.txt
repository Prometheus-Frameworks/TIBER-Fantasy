import { Request, Response } from 'express';
import { calculateVORP } from './vorp_calculator'; // Assuming this is your module path

// POST /api/trade-eval
app.post('/api/trade-eval', async (req: Request, res: Response) => {
  const { teamA, teamB, settings } = req.body;

  if (!teamA || !teamB || !Array.isArray(teamA) || !Array.isArray(teamB) || teamA.length === 0 || teamB.length === 0) {
    return res.status(400).json({ error: 'Invalid request: Provide non-empty teamA and teamB as arrays of player names.' });
  }

  const vorpMap = await calculateVORP(settings || {
    format: 'ppr',
    num_teams: 12,
    starters: { QB: 1, RB: 2, WR: 3, TE: 1, FLEX: 1 },
    is_superflex: false,
    is_te_premium: false
  });

  function getTeamStats(players: string[]): { totalVorp: number, stdDev: number, vorps: number[] } {
    const vorps = players.map(p => vorpMap[p] || 0);
    const totalVorp = vorps.reduce((sum, v) => sum + v, 0);
    const mean = totalVorp / (vorps.length || 1);
    const variance = vorps.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / (vorps.length || 1);
    const stdDev = Math.sqrt(variance);
    return { totalVorp, stdDev, vorps };
  }

  const statsA = getTeamStats(teamA);
  const statsB = getTeamStats(teamB);
  const totalVorpCombined = statsA.totalVorp + statsB.totalVorp;
  const vorpDiff = Math.abs(statsA.totalVorp - statsB.totalVorp);

  let verdict = 'Unbalanced Trade';

  if (vorpDiff < 0.10 * totalVorpCombined) {
    verdict = 'Fair Trade';
  }

  const varianceGap = Math.abs(statsA.stdDev - statsB.stdDev);

  if (varianceGap > 20) {
    verdict += ' â€“ Lopsided Risk Detected';
  }

  const response: any = {
    teamA_total_vorp: statsA.totalVorp.toFixed(2),
    teamA_std_dev: statsA.stdDev.toFixed(2),
    teamB_total_vorp: statsB.totalVorp.toFixed(2),
    teamB_std_dev: statsB.stdDev.toFixed(2),
    verdict: verdict,
  };

  if (varianceGap > 20) {
    response.note = "One side carries a higher variance risk (star-for-depth structure detected).";
  }

  res.json(response);
});