Totally. When “everything’s wired” but nothing shows in the UI, it’s almost always one of these: the API returns empty (filters too strict), the JSON shape doesn’t match your TS types, or the frontend is pointing at the wrong base URL/caching stale empties.

Here’s a tight, practical debugging checklist for your exact stack.

---

## 0) Quick sanity ping (no code)

Run this in your terminal:

```bash
curl -s "http://localhost:3000/api/players/hot-list?bucket=risers" | jq .
```

You should see:

```json
{
  "week": "...",
  "bucket": "risers",
  "players": [
    {
      "player_id": "sleeper:...",
      "name": "Rome Odunze",
      "pos": "WR",
      "current_ovr": 84,
      "base_ovr": 78,
      "delta_total": 6,
      "compass": {"north": 90,"east": 76,"south": 28,"west": 72},
      "reasons": ["+18pp snaps", "TPRR +0.10"],
      "confidence": "high"
    }
  ]
}
```

If that’s empty or a 4xx/5xx, fix backend first. If it’s good here but blank in the UI, fix frontend.

---

## 1) Make the backend tell you *why* players were excluded

Add a debug path that returns “rejections” so you can see which filter killed them.

In `hotListService.ts` (or where you build the list), add a `debug=true` param:

```ts
// server/services/hotListService.ts
export async function generateHotList(bucket: Bucket, pos?: "WR"|"RB"|"TE", debug=false) {
  const { rows } = await loadWeeklyFrame(); // your seeded rows
  const reasons: Record<string,string[]> = {};

  const mark = (id: string, why: string) => {
    if (!reasons[id]) reasons[id] = [];
    reasons[id].push(why);
  };

  // Example filters
  const volFloor = (r: Row) => {
    if (r.pos === "WR" || r.pos === "TE") return r.routes >= 12;
    if (r.pos === "RB") return r.routes >= 10 || r.carries >= 8;
    return true;
  };

  const filtered = rows.filter(r => {
    if (pos && r.pos !== pos) { mark(r.player_id, "pos_mismatch"); return false; }
    if (!volFloor(r)) { mark(r.player_id, "volume_floor"); return false; }
    if (bucket === "risers" && (r.current_ovr - r.base_ovr) < 5) { mark(r.player_id, "delta<5"); return false; }
    return true;
  });

  if (debug) {
    return { players: filtered, rejections: reasons };
  }
  return { players: filtered };
}
```

Then call `/api/players/hot-list?bucket=risers&debug=true` and look at `rejections`.

Common culprits:

* Volume floor nuking almost everyone.
* Percentile calc needs *multiple players per position*; single WR → everyone ranks p100/p0 and later logic fails.
* You passed `bucket=Risers` (capital R); your route expects lowercase.

---

## 2) Loosen filters for a minute (prove the pipe)

Temporarily set friendlier cuts to confirm the path is good:

* Risers: `>= +3` (not +5)
* Persistence: `>= 1` (not 2)
* Volume floors: WR/TE `routes >= 8`, RB `routes >= 6 || carries >= 6`

If players appear, your logic is fine—your sample data is just too thin/strict.

---

## 3) Frontend: validate query + shape + caching

**A. Query is actually firing the right URL**

```ts
// HotList.tsx
const apiBase = process.env.NEXT_PUBLIC_API_BASE ?? "";
const { data, error, isLoading } = useQuery({
  queryKey: ["hot-list", bucket, pos],
  queryFn: async () => {
    const url = `${apiBase}/api/players/hot-list?bucket=${bucket}${pos ? `&pos=${pos}` : ""}`;
    const res = await fetch(url, { headers: { "Accept": "application/json" }});
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  },
  staleTime: 5 * 60 * 1000,
  retry: 1,
});
```

* Double-check `NEXT_PUBLIC_API_BASE` in your `.env.local`. In dev it’s often `http://localhost:3000` or your proxy port.
* If the backend is at a different port (e.g., 8000), set that.

**B. Types/shape match**
Make sure your UI expects `players` under a root object, not a bare array.

```ts
type HotListResponse = {
  week: string;
  bucket: "risers"|"elite"|"usage_surge"|"value";
  players: Array<{
    player_id: string;
    name: string;
    team: string;
    pos: "WR"|"RB"|"TE";
    current_ovr: number;
    base_ovr: number;
    delta_total: number;
    compass: { north: number; east: number; south: number; west: number };
    reasons: string[];
    confidence: string;
  }>;
};

if (error) return <div>error: {String(error)}</div>;
if (isLoading) return <div>Loading…</div>;
if (!data || data.players?.length === 0) return <div>No matches for this bucket.</div>;
```

Mismatch I see a lot:

* Backend uses `current_ovr`, UI expects `currentOVR`.
* Backend nests `compass` object; UI destructures `north` at root.

**C. React Query cache**
If you tested earlier and got an empty response, your 5-min stale cache might be serving “empty”. Force re-fetch:

```ts
useEffect(() => { queryClient.invalidateQueries({ queryKey: ["hot-list"] }); }, [bucket, pos]);
```

---

## 4) CORS / proxy / dev-prod env

If the browser console says **CORS** or **Network error**:

* In your server, enable CORS for your frontend origin.
* If you’re using Next.js API routes as a proxy, make sure the proxy path matches `/api/players/hot-list` (no trailing slash mismatch).
* In dev, avoid mixed content (https site calling http backend).

---

## 5) Percentiles require a cohort

If your sample has 1–2 players per position, percentile math will be garbage. Quick fix in the service:

* If `count(pos) < 8`, bypass percentile filters and use absolute thresholds so you still render something.

---

## 6) Quick temporary override (to prove the UI renders)

Add a bypass query param for dev:

```ts
// server/routes.ts
if (req.query.force === "1") {
  // return top N by current_ovr without filters
}
```

Hit `/api/players/hot-list?bucket=risers&force=1` and confirm the cards render.

---

## 7) Minimum “known good” seed

Make sure your seed includes at least:

* 6–10 WR, 6–10 RB, 6–10 TE
* Realistic routes/carries and deltas so at least one player per bucket qualifies.

Example values that will pass:

* Odunze WR: `base_ovr 78 → current_ovr 84`, `routes 28`, `delta_routes_pct 0.14`, reasons `["+14 routes%", "TPRR +0.06"]`.

---

## 8) Logging you’ll thank yourself for

Add server-side logs per request:

```ts
console.log("[hot-list]", { bucket, pos, count: players.length, first: players[0]?.name });
```

And client-side:

```ts
console.log("hot-list data", data);
```

---

### Quick triage order (fastest to slowest payoff)

1. `curl` the endpoint → see JSON.
2. Add `debug=true` to see rejection reasons.
3. Loosen cuts (delta ≥3, persistence ≥1, softer floors) → confirm items appear.
4. Fix TS shape mismatch in the UI (`current_ovr` vs `currentOVR`, `compass.*`).
5. Percentile cohort guard (fallback to absolutes with tiny samples).

Ping me with the **curl output** and the **first 20 lines of your HotList.tsx** if you’re still stuck—I’ll zero in on the issue fast.
