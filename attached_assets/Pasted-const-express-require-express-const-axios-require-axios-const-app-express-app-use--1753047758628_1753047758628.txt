const express = require('express');
const axios = require('axios');

const app = express();
app.use(express.json());

const leagueId = '1197631162923614208';
const week = 1;

// Sample fallback if both APIs fail
const simulatedSample = [
  { player_name: "Justin Jefferson", position: "WR", team: "MIN", projected_fpts: 320, receptions: 95, birthdate: "1999-06-16" },
  { player_name: "Christian McCaffrey", position: "RB", team: "SF", projected_fpts: 310, receptions: 80, birthdate: "1996-06-07" },
  { player_name: "Patrick Mahomes", position: "QB", team: "KC", projected_fpts: 305, receptions: 0, birthdate: "1995-09-17" },
  { player_name: "Ja'Marr Chase", position: "WR", team: "CIN", projected_fpts: 290, receptions: 100, birthdate: "2000-03-01" },
  { player_name: "Josh Allen", position: "QB", team: "BUF", projected_fpts: 300, receptions: 0, birthdate: "1996-05-21" }
];

async function fetchAggregatedProjections(settings) {
  try {
    const playersResponse = await axios.get('https://api.sleeper.app/v1/players/nfl');
    const playersData = playersResponse.data;

    let projectionsData = {};

    const projResponse = await axios.get('https://api.sleeper.com/projections/nfl/2025?season_type=regular&position=QB,RB,WR,TE');
    projectionsData = projResponse.data;

    if (Object.keys(projectionsData).length === 0) {
      console.warn('Season projections empty — fallback to league matchups.');
      const matchupsResponse = await axios.get(`https://api.sleeper.app/v1/league/${leagueId}/matchups/${week}`);
      const matchups = matchupsResponse.data;

      if (matchups && matchups.length > 0) {
        for (const matchup of matchups) {
          const starters = matchup.starters || [];
          const startersPoints = matchup.starters_points || [];
          for (let i = 0; i < starters.length; i++) {
            const playerId = starters[i];
            projectionsData[playerId] = { stats: { pts_ppr: startersPoints[i] } }; // PPR league
          }
        }
      } else {
        console.warn('Matchups empty — injecting simulated sample.');
        return simulatedSample;
      }
    }

    let aggregated = [];

    for (const playerId in projectionsData) {
      const proj = projectionsData[playerId];
      const player = playersData[playerId];
      if (player && proj && proj.stats) {
        let fpts = proj.stats.pts_ppr || 0; // PPR league
        if (fpts > 450 || fpts <= 50 || !['QB', 'RB', 'WR', 'TE'].includes(player.position) || player.team === null || player.active === false) {
          console.log('Skipped player:', player.full_name, fpts);
          continue;
        }

        aggregated.push({
          player_name: player.full_name || `${player.first_name} ${player.last_name}`,
          position: player.position,
          team: player.team || 'FA',
          projected_fpts: fpts,
          receptions: proj.stats.rec || 0,
          birthdate: player.birth_date
        });
      }
    }

    const fuse = new Fuse(aggregated, { keys: ['player_name', 'position'], threshold: 0.3 });
    const unique = aggregated.filter((p, i) => {
      const matches = fuse.search({ player_name: p.player_name, position: p.position }).filter(m => m.refIndex !== i);
      if (matches.length) {
        matches.forEach(m => {
          aggregated[m.refIndex].projected_fpts = (aggregated[m.refIndex].projected_fpts + p.projected_fpts) / 2;
        });
        return false;
      }
      return true;
    });

    return unique;
  } catch (error) {
    console.error('Fetch failed:', error);
    return simulatedSample; // Final fallback on error
  }
}

app.get('/api/rankings', async (req, res) => {
  const mode = req.query.mode || 'redraft';
  const settings = {}; // From req
  const projections = await fetchAggregatedProjections(settings);
  // ... VORP, tiers, etc. if needed
  res.json(projections); // Clean array
});

// Rest of app

app.listen(3000, () => console.log('Server up'));