import express, { Request, Response } from 'express';
import axios from 'axios';
import cron from 'node-cron';

const app = express();
app.use(express.json());

const CACHE_TTL = 60 * 60 * 1000; // 1 hour
const cache = { projections: null as PlayerProjection[] | null, lastFetch: 0 };

interface PlayerProjection {
  player_name: string;
  position: string;
  team: string;
  projected_fpts: number;
  receptions?: number;
  birthdate?: string;
}

interface LeagueSettings {
  format: 'standard' | 'ppr' | 'half-ppr';
  num_teams: number;
  starters: { QB: number; RB: number; WR: number; TE: number; FLEX: number };
  is_superflex: boolean;
  is_te_premium: boolean;
}

// Refactored fetch using Sleeper API
async function fetchAggregatedProjections(skipCache = false): Promise<PlayerProjection[]> {
  if (!skipCache && cache.projections && Date.now() - cache.lastFetch < CACHE_TTL) return cache.projections;

  try {
    // Fetch projections
    const projResponse = await axios.get('https://api.sleeper.com/projections/nfl/2025?season_type=regular&position=QB,RB,WR,TE');
    const projectionsData = projResponse.data;

    // Fetch player metadata
    const playersResponse = await axios.get('https://api.sleeper.app/v1/players/nfl');
    const playersData = playersResponse.data;

    const aggregated: PlayerProjection[] = [];
    for (const playerId in projectionsData) {
      const proj = projectionsData[playerId];
      const player = playersData[playerId];
      if (player && proj && proj.stats) {
        aggregated.push({
          player_name: player.full_name || `${player.first_name} ${player.last_name}`,
          position: player.position,
          team: player.team || 'FA',
          projected_fpts: 0, // Set in VORP based on format
          receptions: proj.stats.rec || 0,
          birthdate: player.birth_date
        });
      }
    }

    cache.projections = aggregated;
    cache.lastFetch = Date.now();
    return aggregated;
  } catch (error) {
    console.error('Sleeper API fetch failed:', error);
    return []; // Empty on fail - add fallback if needed
  }
}

// VORP calc (updated to set fpts from Sleeper fields)
async function calculateVORP(settings: LeagueSettings, mode: string = 'redraft', skipCache = false): Promise<{ vorpMap: { [key: string]: number }, tiers: any[] }> {
  let projections = await fetchAggregatedProjections(skipCache);

  // Set projected_fpts from Sleeper's format-specific fields
  projections = projections.map(p => {
    if (settings.format === 'ppr') p.projected_fpts = proj.stats.pts_ppr || p.projected_fpts;
    else if (settings.format === 'half-ppr') p.projected_fpts = proj.stats.pts_half_ppr || p.projected_fpts;
    else p.projected_fpts = proj.stats.pts_std || p.projected_fpts;
    return p;
  });

  // Dynasty age decay and rest of logic (unchanged from previous)
  // ...

  return { vorpMap, tiers };
}

// Endpoints (unchanged, but use new fetch)
app.get('/api/rankings', async (req: Request, res: Response) => {
  const mode = req.query.mode || 'redraft';
  const format = req.query.league_format || 'standard';
  const settings = { ...req.query, format } as any;
  const skipCache = true; // Fresh for toggles
  const { vorpMap, tiers } = await calculateVORP(settings as LeagueSettings, mode as string, skipCache);
  const players = []; // Load your player data
  res.json({ players: players.map(p => ({ ...p, vorp_score: vorpMap[p.player_name] || 1 })), tiers });
});

// Trade-eval and cron (unchanged)

app.listen(3000, () => console.log('Server up'));