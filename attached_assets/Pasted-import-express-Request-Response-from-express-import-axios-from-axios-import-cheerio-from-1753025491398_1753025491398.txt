import express, { Request, Response } from 'express';
import axios from 'axios';
import cheerio from 'cheerio';
import cron from 'node-cron';
import Fuse from 'fuse.js';
import fs from 'fs'; // For JSON fallback

const app = express();
app.use(express.json());

const CACHE_TTL = 60 * 60 * 1000; // 1 hour
const cache = { projections: null as PlayerProjection[] | null, lastFetch: 0 };

interface PlayerProjection {
  player_name: string;
  position: string;
  team: string;
  projected_fpts: number;
  receptions?: number;
  birthdate?: string;
  // Add advanced metrics for multipliers (e.g., from scrape or data)
  yprr?: number; // Yards per route run
  first_down_rr?: number; // 1D/RR
  cpoe?: number; // Completion % over expected
}

interface LeagueSettings {
  format: 'standard' | 'ppr' | 'half-ppr';
  num_teams: number;
  starters: { QB: number; RB: number; WR: number; TE: number; FLEX: number };
  is_superflex: boolean;
  is_te_premium: boolean;
}

// Fetch projections
async function fetchAggregatedProjections(skipCache = false): Promise<PlayerProjection[]> {
  if (!skipCache && cache.projections && Date.now() - cache.lastFetch < CACHE_TTL) return cache.projections;

  let projections: PlayerProjection[] = [];
  // Fetch logic (placeholder - expand with cheerio parsers)
  try {
    // ESPN and Draft Sharks fetches...
  } catch (error) {
    console.error('Fetch failed, using fallback');
    projections = JSON.parse(fs.readFileSync('./projections.json', 'utf8'));
  }

  cache.projections = projections;
  cache.lastFetch = Date.now();
  return projections;
}

// Age calc and penalties (from previous)
function calculateAge(birthdateStr: string): number {
  const birthdate = new Date(birthdateStr);
  const today = new Date();
  let age = today.getFullYear() - birthdate.getFullYear();
  const m = today.getMonth() - birthdate.getMonth();
  if (m < 0 || (m === 0 && today.getDate() < birthdate.getDate())) age--;
  return age;
}

function getFallbackAge(pos: string): number {
  const fallbacks = { WR: 25, RB: 24, TE: 26, QB: 28 };
  return fallbacks[pos] || 25;
}

const agePenalties = {
  WR: { 27: 0.03, 28: 0.05, 29: 0.07, 30: 0.10, 31: 0.15, '32': 0.20 },
  RB: { 26: 0.05, 27: 0.08, 28: 0.12, 29: 0.18, '30': 0.25 },
  TE: { 29: 0.05, 30: 0.08, 31: 0.10, '32': 0.15 },
  QB: { 35: 0.05, 37: 0.10, '40': 0.15 }
};

// VORP calc with fixes
async function calculateVORP(settings: LeagueSettings, mode: string = 'redraft', skipCache = false): Promise<{ vorpMap: { [key: string]: number }, tiers: any[] }> {
  let projections = await fetchAggregatedProjections(skipCache);

  // Dynasty age decay
  if (mode === 'dynasty') {
    projections = projections.map(p => {
      let age = p.birthdate ? calculateAge(p.birthdate) : getFallbackAge(p.position);
      if (!p.birthdate) console.warn(`Missing birthdate for ${p.player_name}`);
      const penalties = agePenalties[p.position] || {};
      let penaltyPct = 0;
      for (const [key, pct] of Object.entries(penalties)) {
        if (key.endsWith('+') && age >= parseInt(key.slice(0, -1))) penaltyPct = pct as number;
        else if (age === parseInt(key)) penaltyPct = pct as number;
      }
      p.projected_fpts *= (1 - penaltyPct);
      return p;
    });
  }

  // Baselines, weights, raw VORP (placeholder - expand)
  const vorpMap: { [key: string]: number } = {};
  projections.forEach(p => vorpMap[p.player_name] = p.projected_fpts); // Raw VORP logic

  // Post-VORP multipliers (for OASIS etc.)
  const oasisWeight = settings.oasis_weight || 0; // From param
  const yprrWeight = settings.yprr_weight || 0;
  // ... other weights

  for (const p of projections) {
    let modifiersLog = [];
    let multiplier = 1;

    // OASIS (placeholder - custom logic)
    const oasisBoost = 1 + oasisWeight * (p.projected_fpts / 200); // Example
    multiplier *= oasisBoost;
    modifiersLog.push(`OASIS +${(oasisBoost - 1) * 100}%`);

    // YPRR
    if (p.yprr) {
      const yprrBoost = 1 + yprrWeight * (p.yprr / 2.0 - 1); // Avg YPRR ~2.0
      multiplier *= yprrBoost;
      modifiersLog.push(`YPRR +${(yprrBoost - 1) * 100}%`);
    }

    // 1D/RR, CPOE similar...

    vorpMap[p.player_name] *= multiplier;
    console.debug(`[DEBUG] ${p.player_name}: ${modifiersLog.join(', ')}, final VORP pre-norm = ${vorpMap[p.player_name]}`);
  }

  // Normalization fix
  const vorps = Object.values(vorpMap).filter(v => v > 0);
  const maxVorp = Math.max(...vorps, 1);
  for (const name in vorpMap) {
    vorpMap[name] = vorpMap[name] > 0 ? Math.round((vorpMap[name] / maxVorp) * 99) : 1;
  }

  // Tiers (from previous)
  const sortedPlayers = projections.sort((a, b) => vorpMap[b.player_name] - vorpMap[a.player_name]);
  const tiers = [];
  let currentTier = [sortedPlayers[0]];
  let tierNum = 1;
  for (let i = 1; i < sortedPlayers.length; i++) {
    const drop = (vorpMap[sortedPlayers[i-1].player_name] - vorpMap[sortedPlayers[i].player_name]) / vorpMap[sortedPlayers[i-1].player_name];
    if (drop > 0.15) {
      tiers.push({ tier: tierNum++, players: currentTier });
      currentTier = [sortedPlayers[i]];
    } else {
      currentTier.push(sortedPlayers[i]);
    }
  }
  if (currentTier.length) tiers.push({ tier: tierNum, players: currentTier });

  return { vorpMap, tiers };
}

// Rankings endpoint
app.get('/api/rankings', async (req: Request, res: Response) => {
  const mode = req.query.mode || 'redraft';
  const skipCache = true; // Force fresh for mode toggle
  const settings = { ...req.query } as any; // Pull weights like oasis_weight
  const { vorpMap, tiers } = await calculateVORP(settings as LeagueSettings, mode as string, skipCache);
  const players = [] as any[]; // Load your player data
  res.json({ players: players.map(p => ({ ...p, vorp_score: vorpMap[p.player_name] || 1 })), tiers });
});

// Trade-eval (with mode)
app.post('/api/trade-eval', async (req: Request, res: Response) => {
  const mode = req.body.mode || 'redraft';
  const settings = req.body.settings || {};
  const skipCache = true;
  const { vorpMap } = await calculateVORP(settings as LeagueSettings, mode, skipCache);
  // ... (Lamar's full code using vorpMap)
});

// Cron refresh
cron.schedule('0 0 * * 0', async () => {
  console.log('Weekly refresh');
  await fetchAggregatedProjections(true); // Force
});

app.listen(3000, () => console.log('Server up'));