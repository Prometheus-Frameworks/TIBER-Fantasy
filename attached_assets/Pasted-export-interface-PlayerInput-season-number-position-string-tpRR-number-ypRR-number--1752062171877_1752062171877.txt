export interface PlayerInput {
  season: number;
  position: string;
  tpRR: number;
  ypRR: number;
  oneDRR: number;
  firstReadTargetPct: number;
  fantasyPointsPerGame: number;
  dropRate: number;
  routeWinRate: number;
  age: number;
  draftCapital: 'R1' | 'R2' | 'R3' | 'R4+' | 'UDFA';
  explosivePlayRate: number;
  slotRate: number;
  routeParticipation: number;
  teamPassAttemptsPerGame: number;
  wrRoomTargetCompetition: number;
  qbStabilityScore: number;
  previousSeasons?: {
    season: number;
    ypRR: number;
    tpRR: number;
    targetShare: number;
    firstReadTargetPct: number;
  }[];
}

export interface EvaluationOutput {
  contextScore: number;
  logs: string[];
  tags: string[];
  subScores: {
    usageProfile: number;
    efficiency: number;
    roleSecurity: number;
    growthTrajectory: number;
  };
  lastEvaluatedSeason: number;
}

export class WREvaluationService {
  private version = '1.1';
  private readonly weights = {
    usageProfile: 0.3,
    efficiency: 0.3,
    roleSecurity: 0.2,
    growthTrajectory: 0.2,
  };

  evaluate(player: PlayerInput): EvaluationOutput {
    const logs: string[] = [];
    const tags: string[] = [];

    const usage = this.evaluateUsageProfile(player);
    const efficiency = this.evaluateEfficiency(player);
    const security = this.evaluateRoleSecurity(player);
    const growth = this.evaluateGrowthTrajectory(player);

    logs.push(...usage.logs, ...efficiency.logs, ...security.logs, ...growth.logs);
    tags.push(...usage.tags, ...efficiency.tags, ...security.tags, ...growth.tags);

    const contextScore =
      usage.score * this.weights.usageProfile +
      efficiency.score * this.weights.efficiency +
      security.score * this.weights.roleSecurity +
      growth.score * this.weights.growthTrajectory;

    return {
      contextScore: Math.round(contextScore),
      logs,
      tags: [...new Set(tags)],
      subScores: {
        usageProfile: usage.score,
        efficiency: efficiency.score,
        roleSecurity: security.score,
        growthTrajectory: growth.score,
      },
      lastEvaluatedSeason: player.season,
    };
  }

  private evaluateUsageProfile(player: PlayerInput) {
    let score = 0;
    const logs: string[] = [];
    const tags: string[] = [];

    if (player.tpRR > 0.22) {
      score += 25;
      logs.push("High TPRR");
      tags.push("Alpha Usage");
    } else if (player.tpRR < 0.15) {
      score -= 15;
      logs.push("Low TPRR");
      tags.push("Spike Risk");
    }

    if (player.firstReadTargetPct > 0.28) {
      score += 20;
      logs.push("Strong First Read %");
    }

    if (player.routeParticipation > 0.90) {
      score += 20;
      logs.push("Elite Route Participation");
    }

    if (player.teamPassAttemptsPerGame > 34) {
      score += 10;
      logs.push("High Team Pass Volume");
    }

    return { score: Math.max(0, Math.min(score, 100)), logs, tags };
  }

  private evaluateEfficiency(player: PlayerInput) {
    let score = 0;
    const logs: string[] = [];
    const tags: string[] = [];

    if (player.ypRR >= 2.2) {
      score += 25;
      logs.push("Elite YPRR");
      tags.push("Efficiency Monster");
    } else if (player.ypRR >= 1.8) {
      score += 15;
      logs.push("Good YPRR");
    } else {
      score -= 10;
      logs.push("Poor YPRR");
    }

    if (player.oneDRR >= 0.08) {
      score += 15;
      logs.push("Strong First Down Rate");
    }

    if (player.explosivePlayRate >= 18) {
      score += 10;
      logs.push("Explosive Playmaker");
      tags.push("Field-Stretcher");
    }

    if (player.dropRate < 3.0) {
      score += 10;
      logs.push("Reliable Hands");
    } else if (player.dropRate > 6.0) {
      score -= 10;
      logs.push("Drop Concerns");
      tags.push("Ball Security Risk");
    }

    if (player.routeWinRate >= 45.0) {
      score += 15;
      logs.push("Elite Route Winner");
      tags.push("Separation Specialist");
    }

    return { score: Math.max(0, Math.min(score, 100)), logs, tags };
  }

  private evaluateRoleSecurity(player: PlayerInput) {
    let score = 0;
    const logs: string[] = [];
    const tags: string[] = [];

    // Draft Capital
    switch (player.draftCapital) {
      case 'R1':
        score += 25;
        logs.push("Round 1 Draft Capital");
        tags.push("Team Investment");
        break;
      case 'R2':
        score += 20;
        logs.push("Round 2 Draft Capital");
        break;
      case 'R3':
        score += 10;
        logs.push("Day 2 Draft Capital");
        break;
      case 'UDFA':
        score -= 15;
        logs.push("Undrafted Risk");
        tags.push("Volatility Risk");
        break;
    }

    // Age
    if (player.age <= 25) {
      score += 10;
      logs.push("Age on Side");
    } else if (player.age >= 29) {
      score -= 10;
      logs.push("Age Decline Risk");
    }

    // Slot Role
    if (player.slotRate >= 60.0) {
      logs.push("High Slot Usage");
      tags.push("Slot WR");
    }

    return { score: Math.max(0, Math.min(score, 100)), logs, tags };
  }

  private evaluateGrowthTrajectory(player: PlayerInput) {
    let score = 0;
    const logs: string[] = [];
    const tags: string[] = [];

    if (!player.previousSeasons || player.previousSeasons.length === 0) {
      logs.push("No prior data for growth evaluation");
      return { score: 50, logs, tags };
    }

    const lastSeason = player.previousSeasons[player.previousSeasons.length - 1];
    
    const yprrGrowth = player.ypRR - lastSeason.ypRR;
    const tpRRGrowth = player.tpRR - lastSeason.tpRR;

    if (yprrGrowth > 0.3) {
      score += 15;
      logs.push("Big YPRR Growth");
      tags.push("Breakout Trend");
    }

    if (tpRRGrowth > 0.04) {
      score += 10;
      logs.push("Increased Target Role");
    }

    if (player.qbStabilityScore > 75) {
      score += 10;
      logs.push("Stable QB Environment");
    } else if (player.qbStabilityScore < 40) {
      score -= 10;
      logs.push("QB Volatility Risk");
    }

    return { score: Math.max(0, Math.min(score, 100)), logs, tags };
  }
}