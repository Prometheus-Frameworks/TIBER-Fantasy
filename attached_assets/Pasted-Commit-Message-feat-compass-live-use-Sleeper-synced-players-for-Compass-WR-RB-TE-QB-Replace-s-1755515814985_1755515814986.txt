Commit Message
feat(compass-live): use Sleeper-synced players for Compass (WR/RB/TE/QB)

- Replace sample data with sleeperSyncService.getPlayers()
- zod-validate params; fix param vs query bug
- Add LRU response cache (5m) + per-request pagination
- Null-safe mapping of stats/tags/draft fields

File: routes/compassRoutes.ts (replace the dynamic route)
import { Express, Request, Response } from "express";
import { z } from "zod";
import LRU from "lru-cache";
import { playerCompassService } from "@/services/playerCompassService";
import { sleeperSyncService } from "@/services/sleeperSyncService";

const Query = z.object({
  format: z.enum(["dynasty", "redraft"]).default("dynasty"),
  limit: z.coerce.number().int().min(1).max(200).optional(),
  page: z.coerce.number().int().min(1).optional(),
  pageSize: z.coerce.number().int().min(10).max(200).optional(),
  team: z.string().max(3).optional(),
  search: z.string().max(64).optional(),
});

// cache whole response by key (fast path)
const respCache = new LRU<string, any>({ max: 200, ttl: 5 * 60 * 1000 });

export const registerCompassRoutes = (app: Express) => {
  app.get("/api/compass/:position", async (req: Request, res: Response) => {
    try {
      // ❗ position is a PATH PARAM, not a query param
      const position = String(req.params.position || "").toUpperCase();
      if (!["WR", "RB", "TE", "QB"].includes(position)) {
        return res.status(400).json({ ok: false, error: "Invalid position. Use WR, RB, TE, or QB" });
      }

      const q = Query.parse(req.query);
      const mode = q.format;
      // support either page/pageSize OR legacy limit
      const page = q.page ?? 1;
      const pageSize = q.pageSize ?? (q.limit ?? 50);
      const offset = (page - 1) * pageSize;

      // cache key includes filters
      const cacheKey = `compass:${position}:${mode}:${page}:${pageSize}:${q.team ?? ""}:${q.search ?? ""}`;
      const cached = respCache.get(cacheKey);
      if (cached) return res.json(cached);

      // 1) pull once; service already hits Sleeper-backed store
      const allPlayers = await sleeperSyncService.getPlayers();

      // 2) filter by position + optional team/search
      let pool = allPlayers.filter((p: any) => p.position === position);
      if (q.team) pool = pool.filter((p: any) => p.team === q.team);
      if (q.search) {
        const s = q.search.toLowerCase();
        pool = pool.filter((p: any) =>
          String(p.name || "").toLowerCase().includes(s)
          || String(p.first_name || "").toLowerCase().includes(s)
          || String(p.last_name || "").toLowerCase().includes(s)
        );
      }

      const total = pool.length;

      // 3) paginate slice
      const slice = pool.slice(offset, offset + pageSize);

      // 4) map -> compass DTO using live stats/tags/draft info
      const results = await Promise.all(
        slice.map(async (p: any) => {
          const compassInput = {
            playerId: p.player_id,
            playerName: p.name,
            position: p.position,        // WR/RB/TE/QB
            team: p.team ?? null,
            age: p.age ?? null,
            rawStats: {
              ...(p.stats ?? {}),
              adp: p.adp ?? null,
              projectedPoints: p.projected_points ?? null,
              ownership: p.ownership_percent ?? null,
            },
            contextTags: p.tags ?? [],
            draftCapital: p.draft_pick ?? p.draftCapital ?? null,
            experience: p.years_exp ?? null,
          };

          const comp = await playerCompassService.calculateCompass(compassInput, mode);

          return {
            id: p.player_id,
            name: p.name,
            team: p.team ?? null,
            age: p.age ?? null,
            adp: p.adp ?? null,
            projected_points: p.projected_points ?? null,
            stats: p.stats ?? null,
            compass: {
              north: comp.north,
              east: comp.east,
              south: comp.south,
              west: comp.west,
              score: comp.score,
            },
            dynastyScore: comp.score, // keep legacy alias for now
            tier: comp.tier,
            insights: comp.insights ?? [],
          };
        })
      );

      // 5) stable sort: score desc, then ADP asc
      results.sort(
        (a: any, b: any) =>
          (b.dynastyScore ?? -1) - (a.dynastyScore ?? -1) ||
          (a.adp ?? 9999) - (b.adp ?? 9999)
      );

      const payload = {
        ok: true,
        position,
        format: mode,
        data: results,
        meta: {
          total,
          page,
          pageSize,
          hasNext: page * pageSize < total,
          ts: new Date().toISOString(),
          source: "Sleeper sync → Compass v2.0",
          filters: { team: q.team ?? null, search: q.search ?? null },
        },
      };

      respCache.set(cacheKey, payload);
      return res.json(payload);
    } catch (err: any) {
      console.error("❌ /api/compass/:position", err);
      return res.status(400).json({ ok: false, error: err?.message ?? "Bad request" });
    }
  });
};


Register before SPA * catch-all (keep this at the top of your API registrations).

Optional: Response Cache helper (if you want it isolated)

services/compassCacheService.ts

import LRU from "lru-cache";
const cache = new LRU<string, any>({ max: 200, ttl: 5 * 60 * 1000 });
export const compassCacheService = {
  get: (k: string) => cache.get(k),
  set: (k: string, v: any) => cache.set(k, v),
  clear: () => cache.clear(),
};


(Then swap respCache for this service in the route.)

Frontend (no UI change required)

Your existing PositionCompassTable can now point at real data:

fetch(`/api/compass/${position}?format=dynasty&page=1&pageSize=50`);

Acceptance Tests

1) Happy path

curl -i "http://localhost:3001/api/compass/WR?format=dynasty&page=1&pageSize=50"


→ 200, JSON { ok: true, position:"WR", data:[...], meta:{ total, page, pageSize, hasNext } }

2) Filters

?team=SF limits to 49ers.

?search=Puka matches by name (case-insensitive).

3) Pagination

Compare page=1&pageSize=25 vs page=2&pageSize=25; non-overlapping; hasNext correct.

4) Null safety

Missing adp/projected_points/stats don’t crash; placeholders present.

5) Param vs query bug fixed

GET /api/compass/wr (lowercase) still works since we normalize req.params.position to upper.

6) Caching

Repeat same query twice: second hit should be materially faster (5-minute cache).

Notes (don’t block this PR)

If sleeperSyncService.getPlayers() is heavy, consider memoizing that call separately (e.g., refresh every 60–120s).

Later: cron precompute per-player Compass to a table/Redis and have this route read only.

Add pg_trgm indexes in the players table if you bring the search server-side later.

Ship this and the Compass pillar is officially live on Sleeper data for all four positions.