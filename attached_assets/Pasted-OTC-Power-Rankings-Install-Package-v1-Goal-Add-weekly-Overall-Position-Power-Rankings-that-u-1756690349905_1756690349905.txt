OTC Power Rankings — Install Package (v1)

Goal: Add weekly Overall + Position Power Rankings that update on real events (injuries, depth-chart/QB changes, actives).
Stack: TypeScript (Fastify), PostgreSQL, optional Redis.

0) Repo scaffold
otc-power/
  /src
    /api
      powerRoutes.ts
    /core
      scoring.ts
      smoothing.ts
      events.ts
      guards.ts
      types.ts
      config.ts
    /data
      facts.ts
      loaders.ts   // pulls from Sleeper, OASIS, logs
    /jobs
      nightlyRecalc.ts
      eventRecalc.ts
      validation.ts
    /infra
      db.ts
      cache.ts
      logger.ts
    server.ts
  /sql
    001_schema.sql
    002_indexes.sql
  .env.example
  package.json
  README.md

1) Environment & deps

.env

NODE_ENV=production
PORT=8084
DATABASE_URL=postgres://user:pass@localhost:5432/otc
REDIS_URL=redis://localhost:6379
SLEEPER_BASE=https://api.sleeper.app/v1
OASIS_BASE=http://oasis-service:8000


package.json (key deps)

{
  "name": "otc-power",
  "type": "module",
  "scripts": {
    "dev": "tsx src/server.ts",
    "recalc:nightly": "tsx src/jobs/nightlyRecalc.ts",
    "recalc:events": "tsx src/jobs/eventRecalc.ts",
    "validate": "tsx src/jobs/validation.ts"
  },
  "dependencies": {
    "fastify": "^4.28.0",
    "pg": "^8.11.0",
    "zod": "^3.23.8",
    "undici": "^6.19.8",
    "ioredis": "^5.3.2",
    "date-fns": "^3.6.0"
  },
  "devDependencies": { "tsx": "^4.7.0", "typescript": "^5.4.0" }
}

2) Database schema

/sql/001_schema.sql

create table players (
  player_id text primary key,
  name text not null,
  team text,
  position text not null
);

create table player_week_facts (
  player_id text not null references players(player_id),
  season int not null,
  week int not null,
  usage_now numeric not null default 0,         -- 0-100 (EWMA xFP, share)
  talent numeric not null default 0,            -- 0-100 (OTC/Fusion north stabilized)
  environment numeric not null default 0,       -- 0-100 (OASIS team/off context)
  availability numeric not null default 0,      -- 0-100 (status, snaps expectation)
  market_anchor numeric not null default 0,     -- 0-100 (tiny weight)
  power_score numeric not null default 0,       -- 0-100 (final)
  confidence numeric not null default 0.5,      -- 0-1
  flags text[] not null default '{}',
  last_update timestamptz not null default now(),
  primary key (player_id, season, week)
);

create table power_ranks (
  season int not null,
  week int not null,
  ranking_type text not null,                   -- OVERALL | QB | RB | WR | TE
  rank int not null,
  player_id text not null references players(player_id),
  power_score numeric not null,
  delta_w int not null default 0,
  generated_at timestamptz not null default now(),
  primary key (season, week, ranking_type, rank)
);

create table events_queue (
  id bigserial primary key,
  event_type text not null,                     -- INJURY, DEPTH_CHART, QB_CHANGE, TRANSACTION
  scope jsonb not null,                         -- { player_id, team, position }
  created_at timestamptz not null default now(),
  processed boolean not null default false
);


/sql/002_indexes.sql

create index on player_week_facts (season, week);
create index on power_ranks (season, week, ranking_type);
create index on events_queue (processed, created_at);

3) Types & weights

/src/core/types.ts

export type Pos = 'QB'|'RB'|'WR'|'TE';
export type RankType = 'OVERALL'|Pos;

export interface ComponentBundle {
  usage_now: number;      // 0-100
  talent: number;         // 0-100
  environment: number;    // 0-100
  availability: number;   // 0-100
  market_anchor: number;  // 0-100
}

export interface PlayerFacts extends ComponentBundle {
  player_id: string;
  season: number;
  week: number;
  position: Pos;
  flags: string[];
  confidence: number;     // 0-1
}

export interface RankItem {
  player_id: string;
  name: string;
  team: string;
  position: Pos;
  power_score: number;
  rank: number;
  delta_w: number;
  confidence: number;
  components: ComponentBundle;
  flags: string[];
}


/src/core/config.ts

export const BASE_WEIGHTS = {
  usage_now: 0.40,
  talent: 0.25,
  environment: 0.20,
  availability: 0.10,
  market_anchor: 0.05
} as const;

export const POS_WEIGHTS: Record<'QB'|'RB'|'WR'|'TE', Partial<typeof BASE_WEIGHTS>> = {
  QB: { usage_now: 0.30, environment: 0.25 },
  RB: {},
  WR: { usage_now: 0.45, environment: 0.20, talent: 0.20, availability: 0.10, market_anchor: 0.05 },
  TE: { usage_now: 0.45, environment: 0.20, talent: 0.20, availability: 0.10, market_anchor: 0.05 }
};

export const SMOOTHING = {
  usage_half_life_weeks: 1.5,
  talent_half_life_weeks: 3.0,
  max_weekly_delta: 8
};

export const EVENT_BYPASS_FLAGS = new Set(['INJURY_STATUS_CHANGE','DEPTH_CHART_CHANGE','QB_CHANGE']);

export const MIN_CONFIDENCE_FOR_LIVE = 0.55; // rookies/new roles start lower

4) Scoring core

/src/core/scoring.ts

import { BASE_WEIGHTS, POS_WEIGHTS } from './config.js';
import { PlayerFacts } from './types.js';

function mergeWeights(pos: PlayerFacts['position']) {
  return { ...BASE_WEIGHTS, ...POS_WEIGHTS[pos] };
}

export function computePowerScore(f: PlayerFacts): number {
  const w = mergeWeights(f.position);
  const score =
    w.usage_now      * f.usage_now +
    w.talent         * f.talent +
    w.environment    * f.environment +
    w.availability   * f.availability +
    w.market_anchor  * f.market_anchor;
  return Math.max(0, Math.min(100, score));
}


/src/core/smoothing.ts

import { SMOOTHING, EVENT_BYPASS_FLAGS } from './config.js';

export function clampDelta(prev: number|undefined, next: number, flags: string[]) {
  if (!prev) return next;
  if (flags.some(f => EVENT_BYPASS_FLAGS.has(f))) return next;
  const cap = SMOOTHING.max_weekly_delta;
  const delta = Math.max(-cap, Math.min(cap, next - prev));
  return Math.max(0, Math.min(100, prev + delta));
}


/src/core/guards.ts

// small-sample & opponent adjustments can plug here later if needed
export function adjustForOpponent(raw: number, multiplier: number) {
  return Math.max(0, Math.min(100, raw * multiplier));
}

5) Data loaders (wire to your existing services)

/src/data/loaders.ts

import { PlayerFacts } from '../core/types.js';
import { fetch as http } from 'undici';

/** Pull usage/efficiency: xFP 3w EWMA, targets/route, RZ share */
export async function loadUsageBundle(player_id: string, season: number, week: number): Promise<number> {
  // TODO: call your DeepSeek/xFP service or nightly table
  // return 0-100 scaled usage score
  return 0; // stub
}

/** Pull talent priors: Fusion North / OTC rating (stabilized) */
export async function loadTalent(player_id: string): Promise<number> {
  return 0; // stub
}

/** OASIS team env + QB stability */
export async function loadEnvironment(team: string): Promise<number> {
  // GET `${process.env.OASIS_BASE}/teams/{team}/env`
  return 0; // stub
}

/** Availability from practice reports + expected snaps */
export async function loadAvailability(player_id: string): Promise<number> {
  return 0; // stub
}

/** Tiny anchor vs market */
export async function loadMarketAnchor(player_id: string): Promise<number> {
  return 0; // stub
}


/src/data/facts.ts

import { PlayerFacts } from '../core/types.js';
import { db } from '../infra/db.js';

export async function upsertFacts(f: PlayerFacts) {
  await db.query(
    `insert into player_week_facts
     (player_id, season, week, usage_now, talent, environment, availability, market_anchor,
      power_score, confidence, flags, last_update)
     values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11, now())
     on conflict (player_id, season, week)
     do update set usage_now=$4, talent=$5, environment=$6, availability=$7, market_anchor=$8,
       power_score=$9, confidence=$10, flags=$11, last_update=now()`,
    [f.player_id, f.season, f.week, f.usage_now, f.talent, f.environment, f.availability, f.market_anchor,
     f.power_score, f.confidence, f.flags]
  );
}

6) Event model

/src/core/events.ts

import { db } from '../infra/db.js';

export type OtcEvent = {
  event_type: 'INJURY'|'DEPTH_CHART'|'QB_CHANGE'|'TRANSACTION';
  scope: { player_id?: string; team?: string; position?: string };
};

export async function enqueueEvent(e: OtcEvent) {
  await db.query(`insert into events_queue (event_type, scope) values ($1,$2)`, [e.event_type, e.scope]);
}

export async function nextUnprocessedEvent() {
  const r = await db.query(`select * from events_queue where processed=false order by created_at asc limit 1`);
  return r.rows[0];
}

export async function markProcessed(id: number) {
  await db.query(`update events_queue set processed=true where id=$1`, [id]);
}

7) Jobs

/src/jobs/nightlyRecalc.ts

// 1) iterate all active players
// 2) refresh component bundles (EWMA updates)
// 3) compute power_score (with clamp to last week)
// 4) materialize /power_ranks for OVERALL and each position

// NOTE: join against last week’s power_score for hysteresis


/src/jobs/eventRecalc.ts

// Poll events_queue every minute (or run via worker):
// - for INJURY/DEPTH_CHART/QB_CHANGE:
//     reload availability/usage/env for scope
//     recompute power_score with BYPASS (no clamp) for directly impacted
//     upsert power_ranks deltas for changed players


/src/jobs/validation.ts

// Backtest: correlate rank vs next-week fantasy points (Spearman), print summary

8) API endpoints

/src/api/powerRoutes.ts

import { FastifyInstance } from 'fastify';
import { db } from '../infra/db.js';

export default async function routes(f: FastifyInstance) {
  f.get('/api/power/:type', async (req, reply) => {
    const { type } = req.params as { type: string };
    const { season, week, live } = req.query as any;
    const ranking_type = type.toUpperCase(); // OVERALL | QB | RB | WR | TE
    const rows = await db.query(
      `select pr.rank, pr.player_id, p.name, p.team, p.position, pr.power_score, pr.delta_w
       from power_ranks pr 
       join players p on p.player_id=pr.player_id
       where pr.season=$1 and pr.week=$2 and pr.ranking_type=$3
       order by pr.rank asc limit 250`,
      [season, week, ranking_type]
    );
    return {
      season: Number(season), week: Number(week), ranking_type,
      generated_at: new Date().toISOString(),
      items: rows.rows.map(r => ({
        player_id: r.player_id,
        name: r.name, team: r.team, position: r.position,
        power_score: Number(r.power_score),
        rank: Number(r.rank),
        delta_w: Number(r.delta_w)
      }))
    };
  });

  f.get('/api/power/player/:id', async (req) => {
    const { id } = req.params as any;
    const { season } = req.query as any;
    const rows = await db.query(
      `select * from player_week_facts where player_id=$1 and season=$2 order by week`,
      [id, season]
    );
    return { player_id: id, season: Number(season), history: rows.rows };
  });

  f.post('/api/power/events', async (req) => {
    // optional: external systems can POST events here
    // body: { event_type, scope }
    return { ok: true };
  });
}


/src/server.ts

import Fastify from 'fastify';
import routes from './api/powerRoutes.js';
import { initDb } from './infra/db.js';

const app = Fastify({ logger: true });
await initDb();
await app.register(routes);
await app.listen({ port: Number(process.env.PORT||8084), host: '0.0.0.0' });

9) Caching

/src/infra/cache.ts

// Optional: cache GET /api/power/* for 5–15 min; bust on event or nightly job completion.


Bust strategy

After nightlyRecalc completes → bust all /api/power/*.

After processing an event → bust keys for affected ranking types (team/pos/overall).

10) What Tiber must wire to your data

Replace stubs in loaders.ts with real calls:

loadUsageBundle: your DeepSeek v3 xFP 3-week EWMA + WR/TE routes & 1st-read, RB rush share + inside-10, QB designed runs. Scale to 0–100.

loadTalent: your Fusion North / OTC rating stabilized (multi-year).

loadEnvironment: OASIS team env + QB stability (0–100).

loadAvailability: practice trend (DNP/LP/FP), expected snaps (actives/inactives).

loadMarketAnchor: tiny weight vs ECR/ADP drift (0–100).

11) Event sources (minimal viable)

Trigger events_queue on:

Injury status flip (OUT↔FP, questionable→fp): event_type='INJURY' scope:{player_id}

Depth-chart change (starter benched/promoted): event_type='DEPTH_CHART' scope:{player_id, team}

QB change (team-wide WR/TE impact): event_type='QB_CHANGE' scope:{team}

You can feed these from:

Sleeper actives/inactives + roster changes

Your internal depth-chart monitor

Manual POST to /api/power/events (for now)

12) Ranking materialization

Nightly:

Recompute player_week_facts (clamped to last week unless flags).

Build sorted arrays for:

OVERALL: all players

QB/RB/WR/TE: position filters

Store into power_ranks & compute delta_w vs prior week.

On event:

Recompute facts for impacted player(s)/team(s) without clamp, update their positions in power_ranks, adjust delta_w for visible movement.

13) Validation (sanity)

src/jobs/validation.ts:

Join last week’s rank → next week’s fantasy points.

Report Spearman by position + Top-12→Top-18 hit rate.

Log drift vs market to prove edge.

14) UI contract (what the frontend will get)

GET /api/power/WR?season=2025&week=1

{
  "season": 2025,
  "week": 1,
  "ranking_type": "WR",
  "generated_at": "2025-08-31T14:22:00Z",
  "items": [{
    "player_id": "wr_1234",
    "name": "Puka Nacua",
    "team": "LA",
    "position": "WR",
    "power_score": 92.6,
    "rank": 1,
    "delta_w": 3
  }]
}

15) Tiber’s task list (copy/paste)

Bootstrap repo using scaffold above; add Fastify + PG + Zod.

Run /sql/001_schema.sql and /sql/002_indexes.sql.

Implement /infra/db.ts and /infra/logger.ts (standard patterns).

Wire loaders.ts to OTC services:

DeepSeek/xFP (EWMA), OASIS, availability, market anchor.

Implement nightlyRecalc.ts:

Iterate active players; upsert player_week_facts; compute power_ranks for OVERALL + each position; compute delta_w.

Implement eventRecalc.ts:

Poll events_queue every 60s; recompute impacted facts; update ranks; bust cache.

Expose API in powerRoutes.ts and mount in server.ts.

Add optional Redis cache for /api/power/* (ttl 300–900s) + busting hooks.

Add validation.ts backtest and log weekly metrics.

Prepare README with env, scripts, and endpoint docs.

16) Strong take (design guardrails)

Don’t chase live play-by-play yet. Event-driven + nightly gets you 90% “live” without flakiness.

Hysteresis (±8 pts/week) prevents clown-car swings; bypass only on real events.

WR/TE rankings should lean on routes + 1st-read + RZ; RB on inside-10 + two-minute; QB on environment + designed runs.

Keep market_anchor tiny (5%). Edge dies if you copy consensus.