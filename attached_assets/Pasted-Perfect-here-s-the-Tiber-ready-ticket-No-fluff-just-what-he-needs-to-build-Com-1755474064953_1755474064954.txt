Perfect — here’s the **Tiber-ready ticket**. No fluff, just what he needs to build.

---

## Commit Message

```
feat(players): unified paginated players API + debounced table (SSR-safe)

- Add /api/players backed by unifiedPlayerService (paginated, ilike search)
- Zod-validated query params; returns { ok, data, meta{total,page,pageSize,hasNext} }
- New PaginatedPlayerTable with TanStack Query, debounce, URL state sync
- Compass calc cached in-process (LRU 10m); injuries batch-joined
```

---

## Files to Add / Update

### 1. `services/unifiedPlayerService.ts`

```ts
import { db } from "@/db";
import { players, playerInjuries } from "@/shared/schema";
import { and, eq, ilike, or, sql } from "drizzle-orm";
import LRU from "lru-cache";
import { PlayerCompassService } from "./playerCompassService";

export interface UnifiedPlayer {
  id: string;
  name: string;
  team?: string;
  pos?: "QB" | "RB" | "WR" | "TE";
  adp?: number | null;
  projectedPoints?: number | null;
  avgPoints?: number | null;
  injuryStatus?: string | null;
  qwen?: { rank?: number | null; tier?: string | null };
  compass?: { score?: number | null; tier?: string | null };
}

const compassCache = new LRU<string, any>({ max: 5000, ttl: 10 * 60 * 1000 });

function compassKey(id: string, mode: "dynasty" | "redraft" = "dynasty") {
  return `${id}:${mode}`;
}

export class UnifiedPlayerService {
  private compassService = new PlayerCompassService();

  async getPlayerPool(filters: { pos?: string; team?: string; search?: string; page?: number; pageSize?: number }) {
    const page = Math.max(1, filters.page ?? 1);
    const pageSize = Math.min(Math.max(10, filters.pageSize ?? 50), 200);
    const offset = (page - 1) * pageSize;

    const conditions = [];
    if (filters.pos) conditions.push(eq(players.position, filters.pos));
    if (filters.team) conditions.push(eq(players.team, filters.team));
    if (filters.search) {
      const q = `%${filters.search}%`;
      conditions.push(or(ilike(players.name, q), ilike(players.firstName, q), ilike(players.lastName, q)));
    }
    const whereClause = conditions.length ? and(...conditions) : undefined;

    const [{ count }] = await db.select({ count: sql<number>`COUNT(*)` }).from(players).where(whereClause ?? sql`TRUE`);

    const basePlayers = await db
      .select({
        sleeperId: players.sleeperId,
        name: players.name,
        team: players.team,
        pos: players.position,
        adp: players.adp,
        projectedPoints: players.projectedPoints,
        avgPoints: players.avgPoints,
        qwenOurRank: players.qwenOurRank,
        qwenOurTier: players.qwenOurTier,
        qwenLastUpdated: players.qwenLastUpdated,
      })
      .from(players)
      .where(whereClause ?? sql`TRUE`)
      .orderBy(sql`${players.adp} NULLS LAST`, players.name)
      .limit(pageSize)
      .offset(offset);

    const ids = basePlayers.map(p => p.sleeperId).filter(Boolean) as string[];
    const injuries = ids.length
      ? await db
          .select({ playerId: playerInjuries.playerId, status: playerInjuries.status })
          .from(playerInjuries)
          .where(sql`${playerInjuries.playerId} = ANY(${ids})`)
      : [];
    const injuryMap = new Map(injuries.map(i => [i.playerId, i.status]));

    const rows: UnifiedPlayer[] = [];
    for (const p of basePlayers) {
      const key = compassKey(p.sleeperId!);
      let cached = compassCache.get(key);
      if (!cached) {
        try {
          cached = this.compassService.calculateCompass(
            { playerId: p.sleeperId!, playerName: p.name ?? "Unknown", position: p.pos, team: p.team, age: 0, rawStats: {}, contextTags: [] },
            "dynasty"
          );
          compassCache.set(key, cached);
        } catch {
          cached = null;
        }
      }
      rows.push({
        id: p.sleeperId!,
        name: p.name ?? "Unknown",
        team: p.team,
        pos: p.pos as any,
        adp: p.adp,
        projectedPoints: p.projectedPoints,
        avgPoints: p.avgPoints,
        injuryStatus: (injuryMap.get(p.sleeperId!) === "ACTIVE" ? "Healthy" : injuryMap.get(p.sleeperId!)) ?? "Healthy",
        qwen: { rank: p.qwenOurRank ?? null, tier: p.qwenOurTier ?? null },
        compass: { score: cached?.score ?? null, tier: cached?.tier ?? null },
      });
    }

    return { rows, total: Number(count), page, pageSize };
  }
}

export const unifiedPlayerService = new UnifiedPlayerService();
```

---

### 2. `routes/playersRoute.ts`

```ts
import { Express, Request, Response } from "express";
import { unifiedPlayerService } from "@/services/unifiedPlayerService";
import { z } from "zod";

const QuerySchema = z.object({
  pos: z.enum(["QB", "RB", "WR", "TE"]).optional(),
  team: z.string().max(3).optional(),
  search: z.string().max(64).optional(),
  page: z.coerce.number().int().min(1).optional(),
  pageSize: z.coerce.number().int().min(10).max(200).optional(),
});

export const registerPlayersRoute = (app: Express) => {
  app.get("/api/players", async (req: Request, res: Response) => {
    try {
      const q = QuerySchema.parse(req.query);
      const { rows, total, page, pageSize } = await unifiedPlayerService.getPlayerPool(q);
      res.json({
        ok: true,
        data: rows,
        meta: {
          source: "unified_player_service",
          version: "1.1",
          ts: new Date().toISOString(),
          total,
          page,
          pageSize,
          hasNext: page * pageSize < total,
          filters: q,
        },
      });
    } catch (err: any) {
      res.status(400).json({ ok: false, error: err?.message ?? "Invalid query" });
    }
  });
};
```

---

### 3. `components/PaginatedPlayerTable.tsx`

```tsx
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { Input } from "@/components/ui/input";
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { useDebounce } from "@/hooks/useDebounce";

const TEAMS = ["ARI","ATL","BAL","BUF","CAR","CHI","CIN","CLE","DAL","DEN","DET","GB","HOU","IND","JAX","KC","LV","LAC","LAR","MIA","MIN","NE","NO","NYG","NYJ","PHI","PIT","SF","SEA","TB","TEN","WAS"];

async function fetchPlayers(filters: any) {
  const params = new URLSearchParams();
  Object.entries(filters).forEach(([k, v]) => v && params.set(k, String(v)));
  const res = await fetch(`/api/players?${params}`);
  const data = await res.json();
  if (!data.ok) throw new Error(data.error);
  return data;
}

export default function PaginatedPlayerTable() {
  const [filters, setFilters] = useState({ pos: "", team: "", search: "", page: 1, pageSize: 50 });
  const debouncedSearch = useDebounce(filters.search, 250);

  const { data, isLoading, isError, error } = useQuery({
    queryKey: ["players", { ...filters, search: debouncedSearch }],
    queryFn: () => fetchPlayers({ ...filters, search: debouncedSearch }),
    staleTime: 5 * 60 * 1000,
    keepPreviousData: true,
  });

  const players = data?.data ?? [];
  const total = data?.meta.total ?? 0;
  const hasNext = data?.meta.hasNext ?? false;

  useEffect(() => {
    const params = new URLSearchParams();
    Object.entries(filters).forEach(([k, v]) => v && params.set(k, String(v)));
    window.history.replaceState(null, "", `?${params}`);
  }, [filters]);

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Fantasy Player Database</h1>
      <div className="flex gap-2 mb-6 flex-wrap items-center">
        <Input placeholder="Search…" value={filters.search} onChange={(e) => setFilters(f => ({ ...f, search: e.target.value, page: 1 }))} className="max-w-xs" />
        <Select value={filters.pos} onValueChange={(v) => setFilters(f => ({ ...f, pos: v, page: 1 }))}>
          <SelectTrigger className="w-32"><SelectValue placeholder="Position" /></SelectTrigger>
          <SelectContent><SelectItem value="">All</SelectItem>{["QB","RB","WR","TE"].map(p => <SelectItem key={p} value={p}>{p}</SelectItem>)}</SelectContent>
        </Select>
        <Select value={filters.team} onValueChange={(v) => setFilters(f => ({ ...f, team: v, page: 1 }))}>
          <SelectTrigger className="w-32"><SelectValue placeholder="Team" /></SelectTrigger>
          <SelectContent><SelectItem value="">All</SelectItem>{TEAMS.map(t => <SelectItem key={t} value={t}>{t}</SelectItem>)}</SelectContent>
        </Select>
      </div>
      {isLoading && <div className="p-4">Loading…</div>}
      {isError && <div className="p-4 text-red-600">Error: {(error as Error).message}</div>}
      {!isLoading && !isError && (
        <>
          <div className="overflow-x-auto border rounded-lg mb-4">
            <table className="w-full text-sm">
              <thead className="bg-muted"><tr><th className="p-3">Player</th><th className="p-3">Team</th><th className="p-3">ADP</th><th className="p-3">Proj</th><th className="p-3">Qwen</th><th className="p-3">Compass</th><th className="p-3">Injury</th></tr></thead>
              <tbody>
                {players.map((p:any) => (
                  <tr key={p.id} className="border-t hover:bg-muted/50">
                    <td className="p-3">{p.name}</td>
                    <td className="p-3">{p.team}</td>
                    <td className="p-3">{p.adp ?? "-"}</td>
                    <td className="p-3">{p.projectedPoints ?? "-"}</td>
                    <td className="p-3">{p.qwen?.rank ?? "-"}</td>
                    <td className="p-3">{p.compass?.score ?? "-"} {p.compass?.tier ?? ""}</td>
                    <td className="p-3">{p.injuryStatus ?? "-"}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
          <div className="flex justify-between items-center">
            <span>Showing {players.length} of {total}</span>
            <div className="flex gap-2">
              <Button disabled={filters.page <= 1} onClick={() => setFilters(f => ({ ...f, page: f.page - 1 }))}>Previous</Button>
              <Button disabled={!hasNext} onClick={() => setFilters(f => ({ ...f, page: f.page + 1 }))}>Next</Button>
            </div>
          </div>
        </>
      )}
    </div>
  );
}
```

---

### 4. `hooks/useDebounce.ts`

```ts
import { useEffect, useState } from "react";
export function useDebounce<T>(value: T, delay = 250) {
  const [v, setV] = useState(value);
  useEffect(() => {
    const t = setTimeout(() => setV(value), delay);
    return () => clearTimeout(t);
  }, [value, delay]);
  return v;
}
```

---

## Acceptance Tests

1. `GET /api/players?page=1&pageSize=50` → ok=true, data array, meta with total/page/pageSize/hasNext.
2. Filters (`pos=WR&team=LAR`) restrict correctly.
3. Search (`search=Puka`) matches case-insensitive.
4. Pagination slices data; `hasNext` flips when past end.
5. UI renders nulls as `-` or `—`, no crashes.

---

Send this ticket to Tiber — he can build straight from it.
