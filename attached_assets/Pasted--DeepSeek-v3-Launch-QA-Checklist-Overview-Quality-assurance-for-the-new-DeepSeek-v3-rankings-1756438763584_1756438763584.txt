# DeepSeek v3 Launch QA Checklist

## Overview
Quality assurance for the new DeepSeek v3 rankings endpoint featuring dynasty/redraft modes, tier clustering, and ADP delta analysis.

## Response Schema Validation

### Core Endpoint Structure
```bash
# Basic functionality tests
curl "/api/rankings/deepseek/v3?mode=dynasty"
curl "/api/rankings/deepseek/v3?mode=redraft"
curl "/api/rankings/deepseek/v3?mode=dynasty&league_id=12345"

# Parameter validation
curl "/api/rankings/deepseek/v3?mode=INVALID"
# Expected: 400 error

curl "/api/rankings/deepseek/v3"
# Expected: 400 error (mode required)
```

### Expected Response Schema
```json
{
  "mode": "dynasty|redraft",
  "count": 500,
  "data": [
    {
      "rank": 1,
      "player_id": "string", 
      "name": "string",
      "pos": "RB|WR|TE|QB",
      "team": "string",
      "age": 24,
      "tier": 1,
      "score": 95.3,
      "adp": 3.2,
      "delta_vs_adp": -2.2
    }
  ]
}
```

### Schema Validation Tests
```javascript
// Validate response structure
const response = await fetch('/api/rankings/deepseek/v3?mode=dynasty');
const data = await response.json();

// Required fields present
console.assert(data.mode === 'dynasty', 'Mode field missing or incorrect');
console.assert(typeof data.count === 'number', 'Count field missing or not number');
console.assert(Array.isArray(data.data), 'Data field missing or not array');
console.assert(data.count === data.data.length, 'Count mismatch with data length');

// Player object validation
data.data.slice(0, 10).forEach((player, i) => {
  console.assert(player.rank === i + 1, `Rank should be ${i + 1}, got ${player.rank}`);
  console.assert(typeof player.player_id === 'string', 'player_id missing');
  console.assert(typeof player.name === 'string', 'name missing'); 
  console.assert(['RB', 'WR', 'TE', 'QB'].includes(player.pos), 'Invalid position');
  console.assert(typeof player.team === 'string', 'team missing');
  console.assert(typeof player.age === 'number', 'age missing or not number');
  console.assert(typeof player.tier === 'number', 'tier missing or not number');
  console.assert(typeof player.score === 'number', 'score missing or not number');
  // ADP fields optional but should be numbers if present
  if (player.adp !== null) console.assert(typeof player.adp === 'number', 'adp not number');
  if (player.delta_vs_adp !== null) console.assert(typeof player.delta_vs_adp === 'number', 'delta_vs_adp not number');
});
```

## Score and Ranking Validation

### Score Sorting Verification
```bash
# Scores should be sorted descending
curl "/api/rankings/deepseek/v3?mode=dynasty" | jq -r '.data[0:20] | map(.score) | @csv'
# Expected: Descending order, no score increases

curl "/api/rankings/deepseek/v3?mode=redraft" | jq -r '.data[0:20] | map(.score) | @csv'
# Expected: Same descending pattern
```

### Score Range Validation
```javascript
// Test score bounds and distribution
const dynastyResponse = await fetch('/api/rankings/deepseek/v3?mode=dynasty');
const dynastyData = await dynastyResponse.json();

const redraftResponse = await fetch('/api/rankings/deepseek/v3?mode=redraft');
const redraftData = await redraftResponse.json();

[dynastyData, redraftData].forEach((data, i) => {
  const mode = i === 0 ? 'dynasty' : 'redraft';
  const scores = data.data.map(p => p.score);
  
  // No negative scores
  const negativeScores = scores.filter(s => s < 0);
  console.assert(negativeScores.length === 0, `${mode}: Found ${negativeScores.length} negative scores`);
  
  // Reasonable score range
  const maxScore = Math.max(...scores);
  const minScore = Math.min(...scores);
  console.assert(maxScore <= 100, `${mode}: Max score ${maxScore} exceeds 100`);
  console.assert(minScore >= 0, `${mode}: Min score ${minScore} below 0`);
  
  console.log(`${mode}: Score range ${minScore.toFixed(1)} - ${maxScore.toFixed(1)}`);
});
```

## Tier System Validation

### Tier Cutoffs Enforcement
```javascript
// Validate tiers match config cutoffs: [96, 91, 86, 81, 76, 71]
const TIER_CUTOFFS = [96, 91, 86, 81, 76, 71];

async function validateTiers(mode) {
  const response = await fetch(`/api/rankings/deepseek/v3?mode=${mode}`);
  const data = await response.json();
  
  const tierGroups = {};
  data.data.forEach(player => {
    if (!tierGroups[player.tier]) tierGroups[player.tier] = [];
    tierGroups[player.tier].push(player.score);
  });
  
  Object.keys(tierGroups).forEach(tier => {
    const tierNum = parseInt(tier);
    const scores = tierGroups[tier];
    const maxScore = Math.max(...scores);
    const minScore = Math.min(...scores);
    
    // Validate tier boundaries
    if (tierNum === 1) {
      console.assert(minScore >= TIER_CUTOFFS[0], `Tier 1 min score ${minScore} below cutoff ${TIER_CUTOFFS[0]}`);
    } else if (tierNum <= TIER_CUTOFFS.length) {
      const upperCutoff = TIER_CUTOFFS[tierNum - 2];
      const lowerCutoff = TIER_CUTOFFS[tierNum - 1];
      console.assert(maxScore < upperCutoff, `Tier ${tierNum} max score ${maxScore} not below ${upperCutoff}`);
      console.assert(minScore >= lowerCutoff, `Tier ${tierNum} min score ${minScore} below ${lowerCutoff}`);
    }
    
    console.log(`${mode} Tier ${tierNum}: ${scores.length} players, scores ${minScore.toFixed(1)}-${maxScore.toFixed(1)}`);
  });
}

await validateTiers('dynasty');
await validateTiers('redraft');
```

### Single-Player Tier Check
```bash
# No tiers should have only 1 player unless score gap warrants it
curl "/api/rankings/deepseek/v3?mode=dynasty" | jq -r '
  .data | group_by(.tier) | map({tier: .[0].tier, count: length, min_score: (map(.score) | min), max_score: (map(.score) | max)}) | 
  map(select(.count == 1)) | 
  map("Tier \(.tier): \(.count) player, score \(.min_score)")[]
'
# Expected: Few or no single-player tiers, and only with clear score gaps
```

## ADP Delta Validation

### ADP Data Presence
```bash
# Check ADP coverage
curl "/api/rankings/deepseek/v3?mode=dynasty" | jq -r '
  .data | map(select(.adp != null)) | length as $with_adp |
  "Players with ADP: \($with_adp) / \(length)"
'
# Expected: Significant portion have ADP data
```

### Delta Sanity Checks
```javascript
// Players with earlier ADP should often have smaller |Δ|
async function validateADPDeltas() {
  const response = await fetch('/api/rankings/deepseek/v3?mode=redraft');
  const data = await response.json();
  
  const playersWithADP = data.data.filter(p => p.adp !== null && p.delta_vs_adp !== null);
  
  // Early ADP players (top 24) should generally have smaller absolute deltas
  const earlyADP = playersWithADP.filter(p => p.adp <= 24);
  const earlyADPDeltas = earlyADP.map(p => Math.abs(p.delta_vs_adp));
  const avgEarlyDelta = earlyADPDeltas.reduce((a, b) => a + b, 0) / earlyADPDeltas.length;
  
  // Late ADP players should have more variance
  const lateADP = playersWithADP.filter(p => p.adp > 100);
  const lateADPDeltas = lateADP.map(p => Math.abs(p.delta_vs_adp));
  const avgLateDelta = lateADPDeltas.length > 0 ? lateADPDeltas.reduce((a, b) => a + b, 0) / lateADPDeltas.length : 0;
  
  console.log(`Early ADP (≤24) avg |Δ|: ${avgEarlyDelta.toFixed(2)}`);
  console.log(`Late ADP (>100) avg |Δ|: ${avgLateDelta.toFixed(2)}`);
  
  // Biggest risers/fallers
  const sortedByDelta = playersWithADP.sort((a, b) => a.delta_vs_adp - b.delta_vs_adp);
  console.log('Biggest Fallers (ADP much better than rank):');
  sortedByDelta.slice(0, 5).forEach(p => 
    console.log(`  ${p.name} (${p.pos}): Rank ${p.rank}, ADP ${p.adp}, Δ ${p.delta_vs_adp.toFixed(1)}`)
  );
  
  console.log('Biggest Risers (Rank much better than ADP):');
  sortedByDelta.slice(-5).forEach(p => 
    console.log(`  ${p.name} (${p.pos}): Rank ${p.rank}, ADP ${p.adp}, Δ ${p.delta_vs_adp.toFixed(1)}`)
  );
}

await validateADPDeltas();
```

## Position-Specific Spot Checks

### Score Monotonicity Tests
```javascript
// Test 3 players per position for score math consistency
async function spotCheckPositions() {
  const response = await fetch('/api/rankings/deepseek/v3?mode=dynasty');
  const data = await response.json();
  
  const positions = ['RB', 'WR', 'TE', 'QB'];
  
  positions.forEach(pos => {
    const posPlayers = data.data.filter(p => p.pos === pos).slice(0, 10);
    console.log(`\n${pos} Top 10 Dynasty Rankings:`);
    posPlayers.forEach((p, i) => {
      console.log(`${i + 1}. ${p.name} (${p.team}) - Tier ${p.tier}, Score ${p.score.toFixed(1)}`);
    });
    
    // Validate score decreases monotonically
    for (let i = 1; i < posPlayers.length; i++) {
      if (posPlayers[i].score > posPlayers[i-1].score) {
        console.error(`❌ Score ordering issue: ${posPlayers[i].name} (${posPlayers[i].score}) > ${posPlayers[i-1].name} (${posPlayers[i-1].score})`);
      }
    }
  });
}

await spotCheckPositions();
```

## Performance Testing

### Response Time Validation
```bash
#!/bin/bash
# Test p50 and p95 response times

echo "Testing DeepSeek v3 performance..."

# Dynasty mode timing
echo "Dynasty mode (10 requests):"
for i in {1..10}; do
  curl -w "%{time_total}\n" -o /dev/null -s "/api/rankings/deepseek/v3?mode=dynasty"
done | sort -n | awk '
  {times[NR] = $1}
  END {
    p50_idx = int(NR * 0.5)
    p95_idx = int(NR * 0.95)
    printf "p50: %.3fs, p95: %.3fs\n", times[p50_idx], times[p95_idx]
  }
'

# Redraft mode timing  
echo "Redraft mode (10 requests):"
for i in {1..10}; do
  curl -w "%{time_total}\n" -o /dev/null -s "/api/rankings/deepseek/v3?mode=redraft"
done | sort -n | awk '
  {times[NR] = $1}
  END {
    p50_idx = int(NR * 0.5)
    p95_idx = int(NR * 0.95)
    printf "p50: %.3fs, p95: %.3fs\n", times[p50_idx], times[p95_idx]
  }
'
```

### Performance Assertions
- p50 response time < 300ms ✅
- p95 response time < 600ms ✅
- Memory usage stable across requests ✅
- No timeout errors under normal load ✅

## Guards and Error Handling

### Sleeper Sync Dependency
```bash
# Test require_sleeper_sync_ok guard
# (Assuming sync can be toggled off for testing)
curl -w "%{http_code}" "/api/rankings/deepseek/v3?mode=dynasty"
# If sleeper sync not ready, Expected: 503 Service Unavailable

# When sync is healthy, Expected: 200
```

### Max Players Cap
```bash
# Verify max_players=1000 cap is respected
curl "/api/rankings/deepseek/v3?mode=dynasty" | jq '.count'
# Expected: ≤ 1000
```

### Dry Run Mode Verification
```bash
# Verify dry_run=true doesn't persist to canonical tables
# Check that no writes occur to player_scores or other main tables during v3 computation
```

## UI Integration Tests

### Frontend Page Validation
```bash
# Test /rankings/v3 page
curl -I "http://localhost:3000/rankings/v3"
# Expected: 200 OK

curl -I "http://localhost:3000/rankings/v3?mode=dynasty"
# Expected: 200 OK

curl -I "http://localhost:3000/rankings/v3?mode=redraft"  
# Expected: 200 OK
```

### URL State Persistence
- Navigate to `/rankings/v3` → defaults to dynasty or redraft ✅
- Toggle mode → URL updates with `?mode=` parameter ✅
- Refresh page → maintains selected mode ✅
- Direct link with mode parameter works ✅

## Acceptance Criteria Validation

### API Health Check
```bash
# Must return 200 with count >= 400
RESPONSE=$(curl -s "/api/rankings/deepseek/v3?mode=dynasty")
COUNT=$(echo "$RESPONSE" | jq -r '.count')
echo "Dynasty count: $COUNT"
test "$COUNT" -ge 400 || echo "❌ FAIL: Count below 400"

# Sorted by score desc
FIRST_SCORE=$(echo "$RESPONSE" | jq -r '.data[0].score')
LAST_SCORE=$(echo "$RESPONSE" | jq -r '.data[-1].score')
echo "Score range: $LAST_SCORE - $FIRST_SCORE"
test "$(echo "$FIRST_SCORE >= $LAST_SCORE" | bc)" = "1" || echo "❌ FAIL: Not sorted by score desc"
```

### Eye Test Report Template
```
## DeepSeek v3 Eye Test Results

### Top 20 Dynasty Rankings
RB: [List top 5 RBs with scores]
WR: [List top 5 WRs with scores]  
TE: [List top 5 TEs with scores]
QB: [List top 5 QBs with scores]

### Top 20 Redraft Rankings  
RB: [List top 5 RBs with scores]
WR: [List top 5 WRs with scores]
TE: [List top 5 TEs with scores] 
QB: [List top 5 QBs with scores]

### ADP Delta Insights
Biggest Risers: [Players significantly better than ADP]
Biggest Fallers: [Players significantly worse than ADP]

### Performance Metrics
- Dynasty p50/p95: [timing results]
- Redraft p50/p95: [timing results]
- Total player count: [number]
- ADP coverage: [percentage with ADP data]

### Issues Found
- [Any ranking anomalies]
- [Performance concerns]  
- [Data quality issues]

### Sign-off
✅ Scores sorted correctly
✅ Tiers match cutoffs
✅ No negative scores
✅ Performance under targets
✅ ADP deltas reasonable
✅ Top rankings pass eye test
```

## Final Validation Checklist

- [ ] API returns 200 with count >= 400 for both modes
- [ ] `/rankings/v3` page renders and toggles work
- [ ] Scores sorted descending, ranks 1 to N
- [ ] Tiers respect cutoffs [96, 91, 86, 81, 76, 71]
- [ ] No single-player tiers unless warranted
- [ ] ADP deltas present when ADP available
- [ ] p50 < 300ms, p95 < 600ms
- [ ] Top 20 per position look reasonable
- [ ] No glaring mis-rankings in eye test
- [ ] URL state persistence works
- [ ] Guards (sync health, max players) enforced