Alright, Boss Man J — I read Batch 1 end-to-end. It’s solid, but a few landmines would bite us in prod. Here’s the no-fluff review and the exact fixes. After that, I give you the copy-paste **ingestion wrapper for Tiber** so he patches this safely.

---

# Quick Verdict

Foundation is good: proper types, disk+mem cache, normalization, clean bundle build.
Main gaps: **cache meta export**, **uniform error contract**, **season validation**, **logging shape**, **partial-206 handling**, and a couple of tiny robustness tweaks.

---

# High-Impact Fixes (do these)

## 1) Export a proper cache meta getter (routes need it)

You defined `getCacheMetadata()` but it doesn’t return `count`, and the name doesn’t match our contract.

**Add/replace:**

```ts
// Replace getCacheMetadata with this:
export function getPlayersCacheMeta(): { updatedAt: string | null; count: number } {
  const count = playersCache.data ? Object.keys(playersCache.data).length : 0;
  return {
    updatedAt: playersCache.updatedAt ? playersCache.updatedAt.toISOString() : null,
    count
  };
}
```

*(If routes already imported `getCacheMetadata`, keep a tiny shim for now to avoid breakage and delete later.)*

```ts
// Temporary shim to avoid breakage; remove after route patch
export const getCacheMetadata = getPlayersCacheMeta;
```

---

## 2) Standardize error throwing in the service (so routes can format consistently)

Right now it throws plain objects with ad-hoc fields. Add a tiny helper and use it everywhere:

```ts
function err(code: string, message: string, details?: any, status?: number) {
  const e: any = new Error(message);
  e.code = code;
  e.details = details;
  if (status) e.status = status;
  return e;
}
```

**Examples (replace existing throws):**

```ts
if (!username?.trim()) throw err('INVALID_USERNAME', 'Username is required', null, 400);
// ...
if (error.response?.status === 404) throw err('USER_NOT_FOUND', `User '${username}' not found`, null, 404);
// ...
throw err('API_ERROR', 'Failed to resolve user', error.message, 502);
```

**Partial 206 in `materializeLeagueContext`:**

```ts
if (missing.length > 0) {
  throw err('PARTIAL_UPSTREAM', 'Some upstream resources failed', { missing, context }, 206);
}
```

*(The routes will catch this and emit `{ ok:false, code, message, details, meta }` with HTTP 206.)*

---

## 3) Season validation should be dynamic, not 2020–2030 hard-coded

```ts
function validateSeason(season: string): boolean {
  if (!/^\d{4}$/.test(season)) return false;
  const y = Number(season);
  const current = new Date().getFullYear();
  return y >= 2018 && y <= current + 1;
}
```

And surface **422** on invalid season:

```ts
if (!validateSeason(season)) throw err('INVALID_SEASON', 'Season must be YYYY between 2018 and next year', { season }, 422);
```

---

## 4) Make logging structured (JSON), not mixed strings

Replace the two loggers so every line is machine-parseable:

```ts
function logInfo(msg: string, meta?: Record<string, any>): void {
  console.log(JSON.stringify({ level: 'info', src: 'SleeperSync', msg, ...(meta || {}) }));
}
function logError(msg: string, error: any, meta?: Record<string, any>): void {
  console.error(JSON.stringify({
    level: 'error',
    src: 'SleeperSync',
    msg,
    error: error?.message || String(error),
    stack: error?.stack,
    ...(meta || {})
  }));
}
```

Use `durationMs` where useful:

```ts
const t0 = Date.now();
// ... work ...
logInfo('Retrieved user leagues', { userId, season, count: leagues.length, durationMs: Date.now()-t0 });
```

---

## 5) Axios hardening: timeouts + base client

Avoid hanging calls and reduce repetition:

```ts
const http = axios.create({
  baseURL: 'https://api.sleeper.app/v1',
  timeout: 8000,
  validateStatus: (s) => s >= 200 && s < 500 // let us inspect 4xx
});

// usage:
const res = await http.get(`/user/${encodeURIComponent(username)}`);
```

*(Optional for this batch, but recommended.)*

---

## 6) Minor robustness in players/materialization

* When building `teams`, protect against `roster.players` being nullish (you already handle in bundle, good).
* Make sure `position: 'UNK'` is allowed by the `Player.position` union (it is, because you included `string`; good).
* Free-agent detection: leave as-is (team null → `free_agent:true`), that’s exactly what we want.

If you want to be ultra-defensive:

```ts
players: Array.isArray(roster.players) ? roster.players : [],
```

---

## 7) Route-layer expectations (so this service integrates clean)

Service should only **throw**. The **routes** will:

* Convert thrown errors into:

  ```json
  { "ok": false, "code": "...", "message": "...", "details": { ... }, "meta": { "source": "sleeper", "generatedAt": "..." } }
  ```
* Use `status` if present (206/400/404/422/502); else 500.
* On success:

  ```json
  { "ok": true, "meta": { "source":"sleeper", "generatedAt": "..." }, "data": { ... } }
  ```

Your current `PartialSuccess<T>` type has `ok:false` which is fine for 206; **keep that at the route level**, not the service. The service just throws the 206 marker (above).

---

# Tiny nits (not blockers, but nice)

* Team normalization map: you already handle JAX→JAC, LAS→LV. That’s enough.
* Consider adding `WSH`→`WAS` if your upstream ever emits it (Sleeper uses `WAS` today).
* Disk cache path is fine; in serverless we’d replace with ephemeral mem-only caching later.

---

# ✅ Tiber Ingestion Wrapper (Batch 1)

Paste this directly to Tiber with the code chunk:

> **Task:** Apply the following refinements to the Sleeper Sync service code you just received. Do not overwrite existing files; add/modify only within the Sleeper service module.
>
> **Changes to make exactly:**
>
> 1. Add an exported function:
>
> ```ts
> export function getPlayersCacheMeta(): { updatedAt: string | null; count: number } {
>   const count = playersCache.data ? Object.keys(playersCache.data).length : 0;
>   return { updatedAt: playersCache.updatedAt ? playersCache.updatedAt.toISOString() : null, count };
> }
> // temporary compatibility export (remove later if unused)
> export const getCacheMetadata = getPlayersCacheMeta;
> ```
>
> 2. Add a standard error helper and replace all current `throw { ... }` with it:
>
> ```ts
> function err(code: string, message: string, details?: any, status?: number) {
>   const e: any = new Error(message);
>   e.code = code; if (details !== undefined) e.details = details;
>   if (status) e.status = status;
>   return e;
> }
> ```
>
> * Use **400** for missing params, **422** for invalid season format/range, **404** for not found, **502** for upstream failures.
> * In `materializeLeagueContext`, when `missing.length>0`, throw:
>
> ```ts
> throw err('PARTIAL_UPSTREAM', 'Some upstream resources failed', { missing, context }, 206);
> ```
>
> 3. Replace `validateSeason` with:
>
> ```ts
> function validateSeason(season: string): boolean {
>   if (!/^\d{4}$/.test(season)) return false;
>   const y = Number(season), current = new Date().getFullYear();
>   return y >= 2018 && y <= current + 1;
> }
> ```
>
> 4. Replace log helpers with JSON-structured versions:
>
> ```ts
> function logInfo(msg: string, meta?: Record<string, any>) {
>   console.log(JSON.stringify({ level:'info', src:'SleeperSync', msg, ...(meta||{}) }));
> }
> function logError(msg: string, error: any, meta?: Record<string, any>) {
>   console.error(JSON.stringify({ level:'error', src:'SleeperSync', msg, error: error?.message||String(error), stack: error?.stack, ...(meta||{}) }));
> }
> ```
>
> 5. Optional (good practice): centralize axios via:
>
> ```ts
> const http = axios.create({ baseURL:'https://api.sleeper.app/v1', timeout:8000, validateStatus:(s)=>s>=200&&s<500 });
> ```
>
> and switch existing calls to `http.get(...)`.
>
> **Do not change public function signatures.**
> **After patching, run:** `tsc --noEmit --strict` and ensure zero errors.
>
> **Deliverables:** the updated service file and a short diff summary.

---

When Claude ships Batch 2, drop it here and I’ll rinse/repeat with the same precision.
