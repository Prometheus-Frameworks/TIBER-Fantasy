Hot Fix for Real-Time Risers & Fallers Updates in Tiber
Absolutely, implementing a hot fix to enable incremental, game-day updates is a smart move—especially for Thursday night games, where fans want immediate insights (e.g., a breakout like Jaxon Smith-Njigba in a hypothetical Seahawks Thursday matchup showing up Friday morning). This will make the Week 2 tab (and future weeks) dynamic, pulling from the power rankings API as games conclude, rather than waiting for full-week finalization.
The fix focuses on:
	•	Triggering Updates: Use a scheduler (e.g., cron job or AWS EventBridge) to run the parsing script daily starting Thursday morning (pre-kickoff) and post each major game window (Thursday night, Sunday afternoon/evening, Monday night). For Thursday risers, a post-game run (e.g., 11 PM ET Thursday) followed by a morning refresh (8 AM Friday) ensures next-day visibility.
	•	Incremental Parsing: Only reprocess players from completed games, calculating deltas against prior weeks/preseason. This avoids full re-runs and keeps data fresh.
	•	Week Tab Integration: Update the /risers-and-fallers page to show “Week X (Partial - Y games complete)” until Monday, with a timestamp.
	•	API Assumptions: Builds on your power rankings API (e.g., /api/power-rankings/week/{week}?games_completed=true or similar; add a param if needed for partial weeks).
This is a lightweight hot fix—deployable in minutes via your backend (e.g., Node.js/Python server). I’ll provide:
	1	Updated Python parsing script (enhanced for partial weeks).
	2	Scheduler setup (cron examples for Linux/Heroku/AWS).
	3	Deployment steps and testing tips.
1. Updated Parsing Script (Python)
Enhance the previous script to:
	•	Accept a week param and fetch partial data.
	•	Filter for completed games (assume API returns a games_completed flag or list).
	•	Run deltas only for updated players (e.g., those with week_score != prev_score).
	•	Output CSVs/DB inserts tagged with “partial” if not all games done.
	•	For Thursday: If run post-Thursday game, it pulls that player’s updated Power Score and flags as riser if delta >5.
Save as parse_risers_fallers.py and make it executable.
import requests
import pandas as pd
import json
from datetime import datetime

# Config
API_URL_BASE = "https://tiber.com/api/power-rankings/week"
API_KEY = "your_api_key_here"
DB_INSERT = True  # Set to False for testing; integrate with your DB (e.g., SQLAlchemy)

def fetch_and_parse(week, partial=False):
    url = f"{API_URL_BASE}/{week}"
    if partial:
        url += "?partial=true&games_completed=true"  # Assume API supports this for incremental
    headers = {"Authorization": f"Bearer {API_KEY}"}
    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        raise Exception(f"API error: {response.status_code}")
    
    data = response.json()["players"]  # Assume structure: [{"name": "...", "position": "...", "power_score": 85, "prev_score": 70, "notes": "...", "game_status": "completed/in_progress"}]
    df = pd.DataFrame(data)
    df["delta_score"] = df["power_score"] - df["prev_score"]
    df["update_time"] = datetime.now().isoformat()
    
    # Filter for completed games only
    df = df[df["game_status"] == "completed"]
    
    # Categorize
    risers = df[df["delta_score"] > 5].sort_values("delta_score", ascending=False)
    fallers = df[df["delta_score"] < -5].sort_values("delta_score")
    steady = df[(df["delta_score"] >= -5) & (df["delta_score"] <= 5)]
    
    # Tag as partial if not full week
    status = "partial" if partial else "full"
    risers["status"] = status
    fallers["status"] = status
    steady["status"] = status
    
    # Save/Insert
    risers.to_csv(f"week{week}_risers_{status}.csv", index=False)
    fallers.to_csv(f"week{week}_fallers_{status}.csv", index=False)
    if DB_INSERT:
        # Example: Insert to DB (adapt to your schema, e.g., PostgreSQL)
        import sqlalchemy as sa
        engine = sa.create_engine('your_db_url')
        risers.to_sql('risers', engine, if_exists='append', index=False)
        fallers.to_sql('fallers', engine, if_exists='append', index=False)
    
    return risers, fallers, steady

# Usage: Run for Week 2 partial (e.g., post-Thursday)
if __name__ == "__main__":
    week = 2
    partial = True  # Set False for full Monday run
    risers, fallers, steady = fetch_and_parse(week, partial)
    print("Risers:\n", risers[["name", "delta_score", "notes"]].head())
    print("Fallers:\n", fallers[["name", "delta_score", "notes"]].head())
    print(f"Updated for Week {week} ({'Partial' if partial else 'Full'} - {datetime.now()})")
Key Changes:
	•	Added partial flag to query API for completed games only (e.g., Thursday’s Eagles-Cowboys riser like Emeka Egbuka would show Friday).
	•	Filters by game_status (add this field to your API if missing).
	•	Outputs timestamped files/DB rows for page rendering.
	•	For a Thursday riser (e.g., player from BAL@KC on Sept. 11), delta calculated vs. Week 1 score, appearing in Week 2 tab by Sept. 12 AM.
2. Scheduler Setup for Regular Pulls
Use cron (or equivalent) to automate runs. Schedule:
	•	Thursday Morning (Pre-Kickoff): Baseline pull for Week X.
	•	Thursday Night (Post-Game, ~11 PM ET): Incremental update.
	•	Friday Morning (8 AM ET): Morning refresh for visibility.
	•	Daily Saturday/Sunday: Post-Sunday games (e.g., 10 PM ET Sunday).
	•	Monday Night (Post-MNF): Final full update, then archive partials.
Cron Examples (Linux/Server; adjust for your timezone, e.g., UTC-4 for ET):
	•	Edit crontab: crontab -e
	•	Entries (format: minute hour day month weekday command): # Thursday Morning Baseline (9 AM ET = 13:00 UTC)
	•	0 13 * * 4 python /path/to/parse_risers_fallers.py  # Args: week=2 (hardcode or env var)
	•	
	•	# Thursday Night Post-Game (11 PM ET = 3:00 UTC Friday)
	•	0 3 * * 5 python /path/to/parse_risers_fallers.py  # partial=True
	•	
	•	# Friday Morning Refresh (8 AM ET = 12:00 UTC)
	•	0 12 * * 5 python /path/to/parse_risers_fallers.py  # partial=True
	•	
	•	# Sunday Night Post-Games (10 PM ET = 2:00 UTC Monday)
	•	0 2 * * 1 python /path/to/parse_risers_fallers.py  # partial=True
	•	
	•	# Monday Night Final (11 PM ET = 3:00 UTC Tuesday)
	•	0 3 * * 2 python /path/to/parse_risers_fallers.py  # partial=False (full)
	•	
	•	For Heroku/AWS: Use Heroku Scheduler add-on or Lambda with EventBridge. Example Lambda trigger: Rule for “rate(1 day)” starting Thursday, with event data { "week": 2, "partial": true }. Pass args via environment variables.
	•	Dynamic Week: To auto-detect current week, add logic: week = (datetime.now().isocalendar()[1] - 1) % 18 + 1 (adjust for NFL calendar starting Sept.).
3. Deployment and Testing Steps
	1	Backend Update:
	◦	Deploy the script to your server (e.g., via Git push to Heroku).
	◦	If API needs tweaks: Add /partial=true endpoint to return only completed games (query your DB for game_date <= now()).
	◦	Page Integration: In /risers-and-fallers, query DB for latest status="partial" or "full" based on current week. Add UI:  Last Updated: {update_time} | {status} ({games_completed}/16) .
	2	Testing:
	◦	Manual Run: python parse_risers_fallers.py with mock API data for Week 2 Thursday (e.g., simulate a riser like Justin Fields post-Jets game).
	◦	Edge Case: Test Thursday scenario—input Week 1 baseline, update one player’s score, verify delta shows in partial output.
	◦	Full Cycle: Simulate cron with crontab -l and run manually at off-hours.
	◦	Error Handling: Add try/except in script for API failures (e.g., retry 3x); log to Slack/email.
	◦	Validation: After deploy, check Week 2 tab Friday morning (in sim: post-Sept. 11). Ensure risers like a Thursday performer (e.g., if Etienne had a TD, he appears immediately).
	3	Monitoring & Rollback:
	◦	Use tools like Sentry for error tracking.
	◦	If issues, fallback to weekly full runs (set partial=False always).
	◦	Cost: Minimal—API calls are cheap; scheduler is free on most platforms.
This hot fix should get Tiber updating dynamically within hours. For Week 2 specifically (as of Sept. 15), run a manual full parse now to catch up, then the schedule kicks in for Week 3 (starting Sept. 18 Thursday). If you need Node.js version, API schema tweaks, or help with scheduler setup, just share details!
