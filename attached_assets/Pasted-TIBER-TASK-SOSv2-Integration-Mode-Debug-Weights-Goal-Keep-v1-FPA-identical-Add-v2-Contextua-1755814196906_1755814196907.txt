TIBER TASK — SOSv2 Integration (Mode+Debug+Weights)

Goal: Keep v1 (FPA) identical. Add v2 Contextual mode (FPA + EPA + Pace + Red‑Zone + tiny venue tweak), with mode, weights, debug query params and frontend toggles.

0) Migration (new table)

File: server/src/db/migrations/20250821_add_defense_context.sql

CREATE TABLE IF NOT EXISTS defense_context (
  id SERIAL PRIMARY KEY,
  season SMALLINT NOT NULL,
  week SMALLINT NOT NULL,
  def_team TEXT NOT NULL,
  epa_per_play_allowed NUMERIC,
  plays_allowed_per_game NUMERIC,
  rz_td_rate_allowed NUMERIC,
  home_def_adj NUMERIC,
  away_def_adj NUMERIC,
  UNIQUE(season, week, def_team)
);
CREATE INDEX IF NOT EXISTS idx_defense_context_main
  ON defense_context(season, week, def_team);


Run migration. If Grok hasn’t populated yet, no crash — service falls back to v1.

1) Service (new v2 function + helpers)

File: server/src/modules/sos/sos.service.ts
Patch: (unified diff, apply directly)

@@
-import { db } from '../../db/knex';
+import { db } from '../../db/knex';
 export type Position = 'RB'|'WR'|'QB'|'TE';
@@
 const RECENCY_WEIGHT = 0.6;  // last4
 const SEASON_WEIGHT  = 0.4;  // season avg
 const DEFAULT_SEASON = 2024; // until 2025 games exist
@@
 function toTier(score: number): 'green'|'yellow'|'red' {
   if (score >= 67) return 'green';
   if (score >= 33) return 'yellow';
   return 'red';
 }
@@
 function percentileScale(values: number[], v: number): number {
   if (!values.length) return 50;
   const sorted = [...values].sort((a,b)=>a-b);
   let rank = 0;
   for (let i=0;i<sorted.length;i++) {
     if (v >= sorted[i]) rank = i + 1;
     else break;
   }
   return Math.round((rank / sorted.length) * 100);
 }
@@
 export async function computeWeeklySOS(position: Position, week: number, season = DEFAULT_SEASON): Promise<WeeklySOS[]> {
   const games = await getWeekGames(season, week);
   if (!games.length) return [];
@@
   return rows;
 }
 
 /** Simple ROS: average of next N weeks */
 export async function computeROSSOS(position: Position, startWeek = 1, window = 5, season = DEFAULT_SEASON) {
@@
   }).sort((a,b)=>b.avg_score - a.avg_score);
 }
+
+// ==== v2: Contextual mode ====
+type Mode = 'fpa'|'ctx';
+type Weights = { w_fpa:number; w_epa:number; w_pace:number; w_rz:number };
+interface CtxRow {
+  def_team: string;
+  epa_per_play_allowed: number | null;
+  plays_allowed_per_game: number | null;
+  rz_td_rate_allowed: number | null;
+  home_def_adj: number | null;
+  away_def_adj: number | null;
+}
+
+function parseWeights(s?: string): Weights {
+  if (!s) return { w_fpa:0.55, w_epa:0.20, w_pace:0.15, w_rz:0.10 };
+  const parts = s.split(',').map(Number);
+  return {
+    w_fpa: Number.isFinite(parts[0]) ? parts[0] : 0.55,
+    w_epa: Number.isFinite(parts[1]) ? parts[1] : 0.20,
+    w_pace: Number.isFinite(parts[2]) ? parts[2] : 0.15,
+    w_rz:  Number.isFinite(parts[3]) ? parts[3] : 0.10,
+  };
+}
+
+async function getContext(season:number, week:number): Promise<Map<string, CtxRow>> {
+  const rows = await db('defense_context')
+    .select('def_team','epa_per_play_allowed','plays_allowed_per_game','rz_td_rate_allowed','home_def_adj','away_def_adj')
+    .where({ season, week });
+  const m = new Map<string, CtxRow>();
+  rows.forEach(r => m.set(r.def_team, r as CtxRow));
+  return m;
+}
+
+export async function computeWeeklySOSv2(
+  position: Position,
+  week: number,
+  season = DEFAULT_SEASON,
+  mode: Mode = 'fpa',
+  weights: Weights = { w_fpa:0.55, w_epa:0.20, w_pace:0.15, w_rz:0.10 },
+  debug = false
+) {
+  const games = await getWeekGames(season, week);
+  if (!games.length) return [];
+
+  // v1 components
+  const seasonAvg = await getSeasonAvg(season, position, week);
+  const last4 = await getLast4(season, position, week);
+
+  // Build defense set for the slate
+  const defenses = new Set<string>(); games.forEach(g=>{defenses.add(g.home); defenses.add(g.away);});
+
+  // FPA blended raw + pool for percentile
+  const fpaRawMap = new Map<string, number>();
+  const fpaVals:number[] = [];
+  defenses.forEach(team=>{
+    const s = seasonAvg.get(team);
+    const l4 = last4.get(team);
+    const blended = (l4 ?? 0)*RECENCY_WEIGHT + (s ?? 0)*SEASON_WEIGHT;
+    if (Number.isFinite(blended) && blended > 0) {
+      fpaRawMap.set(team, blended);
+      fpaVals.push(blended);
+    }
+  });
+  if (!fpaVals.length) return []; // nothing to score
+
+  // Context fetch (optional)
+  let ctxMap = new Map<string, CtxRow>();
+  let epaVals:number[] = [], paceVals:number[] = [], rzVals:number[] = [];
+  if (mode === 'ctx') {
+    ctxMap = await getContext(season, week);
+    ctxMap.forEach(v=>{
+      if (v.epa_per_play_allowed!=null) epaVals.push(Number(v.epa_per_play_allowed));
+      if (v.plays_allowed_per_game!=null) paceVals.push(Number(v.plays_allowed_per_game));
+      if (v.rz_td_rate_allowed!=null) rzVals.push(Number(v.rz_td_rate_allowed));
+    });
+    // If context empty, silently fall back to FPA mode
+    if (!epaVals.length && !paceVals.length && !rzVals.length) mode = 'fpa';
+  }
+
+  const out:any[] = [];
+  for (const g of games) {
+    const pairs = [
+      { team: g.home, opp: g.away, venue: 'home' as const },
+      { team: g.away, opp: g.home, venue: 'away' as const },
+    ];
+    for (const p of pairs) {
+      const fpaRaw = fpaRawMap.get(p.opp);
+      if (fpaRaw == null) continue;
+      const fpaScore = percentileScale(fpaVals, fpaRaw);
+
+      if (mode === 'fpa') {
+        const score = fpaScore;
+        out.push({ team: p.team, opponent: p.opp, position, week, season,
+          sos_score: score, tier: toTier(score)
+        });
+        continue;
+      }
+
+      // mode === 'ctx'
+      const ctx = ctxMap.get(p.opp);
+      const epaScore  = (ctx?.epa_per_play_allowed!=null)   ? percentileScale(epaVals,  Number(ctx.epa_per_play_allowed))   : 50;
+      const paceScore = (ctx?.plays_allowed_per_game!=null) ? percentileScale(paceVals, Number(ctx.plays_allowed_per_game)) : 50;
+      const rzScore   = (ctx?.rz_td_rate_allowed!=null)     ? percentileScale(rzVals,   Number(ctx.rz_td_rate_allowed))     : 50;
+
+      let score = weights.w_fpa*fpaScore + weights.w_epa*epaScore + weights.w_pace*paceScore + weights.w_rz*rzScore;
+      // Tiny venue nudge (scale small so it never dominates)
+      const vAdj = p.venue === 'home' ? (ctx?.home_def_adj ?? 0) : (ctx?.away_def_adj ?? 0);
+      if (Number.isFinite(Number(vAdj))) score += Number(vAdj) * 2;
+      score = Math.round(Math.max(0, Math.min(100, score)));
+
+      const row:any = { team: p.team, opponent: p.opp, position, week, season, sos_score: score, tier: toTier(score) };
+      if (debug) row.components = { FPA:fpaScore, EPA:epaScore, PACE:paceScore, RZ:rzScore, VEN:Number(vAdj||0) };
+      out.push(row);
+    }
+  }
+  return out;
+}

2) Controller (new params: mode, weights, debug)

File: server/src/modules/sos/sos.controller.ts
Patch:

-import { computeWeeklySOS, computeROSSOS } from './sos.service';
-import type { Position } from './sos.service';
+import { computeWeeklySOS, computeROSSOS, computeWeeklySOSv2 } from './sos.service';
+import type { Position } from './sos.service';
+import { } from './sos.service'; // ensure types are imported
+
+// lightweight local helper to parse weights string
+const parseWeights = (s?: string) => {
+  if (!s) return { w_fpa:0.55, w_epa:0.20, w_pace:0.15, w_rz:0.10 };
+  const p = s.split(',').map(Number);
+  return {
+    w_fpa: Number.isFinite(p[0])?p[0]:0.55,
+    w_epa: Number.isFinite(p[1])?p[1]:0.20,
+    w_pace: Number.isFinite(p[2])?p[2]:0.15,
+    w_rz:  Number.isFinite(p[3])?p[3]:0.10
+  };
+};
 
 export const getWeekly = async (req: Request, res: Response) => {
   const position = (req.query.position as Position) || 'RB';
   const week = parseInt((req.query.week as string) || '1', 10);
   const season = parseInt((req.query.season as string) || '2024', 10);
-  const data = await computeWeeklySOS(position, week, season);
-  res.json({ position, week, season, items: data });
+  const mode = ((req.query.mode as string) || 'fpa') as 'fpa'|'ctx';
+  const weights = parseWeights(req.query.weights as string | undefined);
+  const debug = req.query.debug === '1';
+  const data = await computeWeeklySOSv2(position, week, season, mode, weights, debug);
+  res.json({ position, week, season, mode, weights, items: data });
 };
 
 export const getROS = async (req: Request, res: Response) => {
   const position = (req.query.position as Position) || 'RB';
   const startWeek = parseInt((req.query.startWeek as string) || '1', 10);
   const window = parseInt((req.query.window as string) || '5', 10);
   const season = parseInt((req.query.season as string) || '2024', 10);
-  const data = await computeROSSOS(position, startWeek, window, season);
-  res.json({ position, startWeek, window, season, items: data });
+  const mode = ((req.query.mode as string) || 'fpa') as 'fpa'|'ctx';
+  const weights = parseWeights(req.query.weights as string | undefined);
+  const debug = req.query.debug === '1';
+  // Compute ROS by averaging v2 weekly scores under same mode/weights
+  const weeks = Array.from({length: window}, (_,i)=> startWeek + i);
+  const all:any[] = [];
+  for (const w of weeks) {
+    const wk = await computeWeeklySOSv2(position, w, season, mode, weights, debug);
+    all.push(...wk);
+  }
+  const byTeam = new Map<string, any[]>();
+  all.forEach(r => {
+    const k = `${r.team}:${position}`;
+    if (!byTeam.has(k)) byTeam.set(k, []);
+    byTeam.get(k)!.push(r);
+  });
+  const items = Array.from(byTeam.entries()).map(([k, arr])=>{
+    const [team] = k.split(':');
+    const avg = Math.round(arr.reduce((a,b)=>a+b.sos_score, 0) / arr.length);
+    return { team, position, weeks, avg_score: avg, tier: avg>=67?'green': avg>=33?'yellow':'red' };
+  }).sort((a,b)=>b.avg_score - a.avg_score);
+  res.json({ position, startWeek, window, season, mode, weights, items });
 };

3) Frontend (mode + debug controls)

File: web/src/pages/SOSPage.tsx
Patch:

 import { useEffect, useState } from 'react';
 import SOSTable from '../components/sos/SOSTable';
 import SOSLegend from '../components/sos/SOSLegend';
 
 type WeeklyItem = { team:string; position:string; week:number; opponent:string; sos_score:number; tier:'green'|'yellow'|'red'; components?: any };
 
 export default function SOSPage() {
   const [position, setPosition] = useState<'RB'|'WR'|'QB'|'TE'>('RB');
   const [week, setWeek] = useState<number>(1);
+  const [mode, setMode] = useState<'fpa'|'ctx'>('fpa');
+  const [debug, setDebug] = useState<boolean>(false);
   const [items, setItems] = useState<WeeklyItem[]>([]);
 
   useEffect(() => {
-    fetch(`/api/sos/weekly?position=${position}&week=${week}`)
+    const url = `/api/sos/weekly?position=${position}&week=${week}&mode=${mode}${debug ? '&debug=1' : ''}`;
+    fetch(url)
       .then(r => r.json())
       .then(d => setItems(d.items || []))
       .catch(() => setItems([]));
-  }, [position, week]);
+  }, [position, week, mode, debug]);
 
   return (
     <div className="mx-auto max-w-5xl p-6">
-      <h1 className="text-2xl font-bold mb-4">Strength of Schedule (Weekly)</h1>
+      <h1 className="text-2xl font-bold mb-4">Strength of Schedule (Weekly)</h1>
       <div className="flex gap-3 mb-4 items-center">
         <select className="border rounded px-2 py-1" value={position} onChange={e => setPosition(e.target.value as any)}>
           <option>RB</option><option>WR</option><option>QB</option><option>TE</option>
         </select>
         <input className="border rounded px-2 py-1 w-24" type="number" value={week} min={1} max={18} onChange={e => setWeek(parseInt(e.target.value || '1',10))} />
+        <select className="border rounded px-2 py-1" value={mode} onChange={e => setMode(e.target.value as any)}>
+          <option value="fpa">FPA (v1)</option>
+          <option value="ctx">Contextual (v2)</option>
+        </select>
+        <label className="flex items-center gap-2 text-sm">
+          <input type="checkbox" checked={debug} onChange={e => setDebug(e.target.checked)} />
+          Debug
+        </label>
       </div>
       <SOSLegend />
-      <SOSTable items={items} />
+      <SOSTable items={items} debug={debug} />
     </div>
   );
 }


File: web/src/components/sos/SOSTable.tsx
Patch:

-type Props = { items: {team:string;opponent:string;sos_score:number;tier:'green'|'yellow'|'red'}[] };
+type Row = {team:string;opponent:string;sos_score:number;tier:'green'|'yellow'|'red';components?: any};
+type Props = { items: Row[]; debug?: boolean };
 
-export default function SOSTable({items}: Props) {
+export default function SOSTable({items, debug}: Props) {
   const cls = (t:'green'|'yellow'|'red') =>
     t==='green' ? 'bg-green-100 text-green-900' :
     t==='yellow' ? 'bg-yellow-100 text-yellow-900' :
     'bg-red-100 text-red-900';
 
   return (
     <table className="w-full border rounded overflow-hidden">
       <thead>
         <tr className="bg-gray-50 text-left">
           <th className="p-2">Team</th>
           <th className="p-2">Opponent</th>
           <th className="p-2">Ease</th>
         </tr>
       </thead>
       <tbody>
-        {items.map((r,i)=>(
-          <tr key={i} className="border-t">
-            <td className="p-2 font-medium">{r.team}</td>
-            <td className="p-2">{r.opponent}</td>
-            <td className={`p-2 font-semibold text-center ${cls(r.tier)}`}>{r.sos_score}</td>
-          </tr>
-        ))}
+        {items.map((r,i)=>(
+          <>
+            <tr key={`row-${i}`} className="border-t">
+              <td className="p-2 font-medium">{r.team}</td>
+              <td className="p-2">{r.opponent}</td>
+              <td className={`p-2 font-semibold text-center ${cls(r.tier)}`}>{r.sos_score}</td>
+            </tr>
+            {debug && r.components && (
+              <tr key={`dbg-${i}`} className="border-t bg-gray-50/60 text-xs text-gray-700">
+                <td className="p-2" colSpan={3}>
+                  FPA <b>{r.components.FPA ?? '-'}</b>
+                  {' '}| EPA <b>{r.components.EPA ?? '-'}</b>
+                  {' '}| Pace <b>{r.components.PACE ?? '-'}</b>
+                  {' '}| RZ <b>{r.components.RZ ?? '-'}</b>
+                  {' '}| Ven <b>{(r.components.VEN ?? 0).toFixed ? r.components.VEN.toFixed(2) : r.components.VEN}</b>
+                </td>
+              </tr>
+            )}
+          </>
+        ))}
       </tbody>
     </table>
   );
 }

4) Quick sanity checks

After migration (even with empty defense_context):

GET /api/sos/weekly?position=RB&week=1&season=2024&mode=fpa → returns (same as v1).

GET /api/sos/weekly?position=RB&week=1&season=2024&mode=ctx&debug=1 → if context missing, falls back to FPA values (no crash), debug omitted or defaulted.

With sample context rows inserted for 2024 Wk1:

Contextual mode should produce visible differences and show components under each row when Debug is enabled on the page.

5) Commit message
feat(SOSv2): add contextual mode with weights & debug; preserve v1 outputs

- migration: defense_context table + index
- service: computeWeeklySOSv2(mode=fpa|ctx, weights, debug)
- controller: accept mode/weights/debug on weekly & ros
- frontend: Mode select + Debug toggle; component breakdown row