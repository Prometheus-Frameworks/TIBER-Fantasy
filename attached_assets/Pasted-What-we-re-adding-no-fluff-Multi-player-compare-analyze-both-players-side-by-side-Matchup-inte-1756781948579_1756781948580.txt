What we’re adding (no fluff)

Multi-player compare: analyze both players side-by-side.

Matchup intelligence: coverage/align vs defense, game script (Vegas), weather, injuries.

Reasoned verdict: “Start Smith over Jeudy” with numbers (expected pts, floor/ceiling, O/U, spread, defense splits).

Confidence: derived from variance and data completeness.

1) New endpoint

POST /api/voice/compare → returns head-to-head with structured reasons.

// src/api/voiceCompareRoutes.ts
import { FastifyInstance } from 'fastify';
import { tiberCompare } from '../voice/compare.js';

export default async function voiceCompareRoutes(app: FastifyInstance) {
  app.post('/api/voice/compare', async (req, reply) => {
    const body = req.body as { players: string[]; season: number; week: number; scoring?: string };
    const res = await tiberCompare(body.players, body.season, body.week, body.scoring || 'PPR');
    return reply.send(res);
  });
}


Register it in server.ts:

import voiceCompareRoutes from './api/voiceCompareRoutes.js';
await app.register(voiceCompareRoutes);

2) Data we’ll use (tiny stubs you can wire later)

Add three lightweight sources (we’ll default to sane fallbacks if missing):

// src/data/sources/vegas.ts
export async function fetchGameOdds(season:number, week:number): Promise<Array<{team:string, opp:string, spread:number, total:number}>> { return []; }

// src/data/sources/weather.ts
export async function fetchGameWeather(season:number, week:number): Promise<Array<{team:string, wind_mph:number, precip: number, temp_f:number}>> { return []; }

// src/data/sources/defenseSplits.ts
export async function fetchDefenseSplits(season:number, week:number): Promise<Array<{team:string,
  vs_wr_slot_ppg:number, vs_wr_outside_ppg:number, vs_te_ppg:number, vs_rb_recv_ppg:number}>> { return []; }

// src/data/sources/alignments.ts
export async function fetchRouteAlign(player_id:string, season:number): Promise<{slot_pct:number, outside_pct:number, inline_pct:number}> { return {slot_pct:0.5, outside_pct:0.5, inline_pct:0}; }


DB (optional, if you want persistence later):

-- odds & weather (optional; can be views or temp tables)
create table if not exists odds_games(season int, week int, team text, opp text, spread numeric, total numeric);
create table if not exists weather_games(season int, week int, team text, wind_mph numeric, precip numeric, temp_f numeric);
create table if not exists defense_splits(season int, week int, team text,
  vs_wr_slot_ppg numeric, vs_wr_outside_ppg numeric, vs_te_ppg numeric, vs_rb_recv_ppg numeric);

3) The comparator (brains)
// src/voice/compare.ts
import { resolvePlayerId, fetchPlayerWeekBundle } from './dataAdapter.js';
import { fetchGameOdds } from '../data/sources/vegas.js';
import { fetchGameWeather } from '../data/sources/weather.js';
import { fetchDefenseSplits } from '../data/sources/defenseSplits.js';
import { fetchRouteAlign } from '../data/sources/alignments.js';

type Verdict = 'Start A'|'Start B'|'Start A (thin)'|'Start B (thin)'|'Coin flip';

export async function tiberCompare(players:string[], season:number, week:number, scoring='PPR') {
  const [aName, bName] = players;
  const [aId, bId] = await Promise.all([resolvePlayerId(aName), resolvePlayerId(bName)]);
  if (!aId || !bId) return { verdict:'Unknown Player', reasons:[`Could not resolve ${!aId? aName : bName}`], tone:'tiber' };

  const [A, B] = await Promise.all([
    fetchPlayerWeekBundle(aId.player_id, season, week),
    fetchPlayerWeekBundle(bId.player_id, season, week)
  ]);
  if (!A || !B) return { verdict:'No Data', reasons:['Missing week facts'], tone:'tiber' };

  // odds, weather, defense splits
  const [odds, weather, def] = await Promise.all([
    fetchGameOdds(season, week), fetchGameWeather(season, week), fetchDefenseSplits(season, week)
  ]);

  const aAdj = await enrich(A, odds, weather, def, season);
  const bAdj = await enrich(B, odds, weather, def, season);

  // expected points with matchup/script/weather adjustments applied
  const aMu = adjustedMu(aAdj);
  const bMu = adjustedMu(bAdj);

  // derive floor/ceiling from each player’s variance (existing) with small matchup/weather adjustments
  const aFloor = (A.floor_points ?? aMu - 2) + aAdj.deltaFloor;
  const aCeil  = (A.ceiling_points ?? aMu + 2) + aAdj.deltaCeil;
  const bFloor = (B.floor_points ?? bMu - 2) + bAdj.deltaFloor;
  const bCeil  = (B.ceiling_points ?? bMu + 2) + bAdj.deltaCeil;

  // advantage score: expected diff, risk, and upside preference
  const diff = aMu - bMu;
  const riskBias = -0.2*((aCeil-aFloor) - (bCeil-bFloor)); // prefer narrower range slightly
  const upsideBias = 0.15*((A.upside_index ?? 0) - (B.upside_index ?? 0)); // Joe likes upside
  const score = diff + riskBias + upsideBias;

  const verdict: Verdict =
    Math.abs(score) < 0.7 ? 'Coin flip' :
    score > 0 ? (Math.abs(score) < 1.5 ? 'Start A (thin)' : 'Start A') :
                (Math.abs(score) < 1.5 ? 'Start B (thin)' : 'Start B');

  const conf = confidenceFromRanges(aFloor,aCeil,bFloor,bCeil);
  const reasons = buildReasons(A,B,aAdj,bAdj,aMu,bMu);
  const headToHead = {
    A: view(A, aMu, aFloor, aCeil),
    B: view(B, bMu, bFloor, bCeil),
    delta_mu: Number((aMu-bMu).toFixed(1))
  };

  return { verdict, confidence: conf, reasons, headToHead, tone:'tiber' };
}

// helpers
async function enrich(p:any, odds:any[], weather:any[], def:any[], season:number) {
  // find team row
  const team = p.team;
  const o = odds.find(x=>x.team===team);
  const w = weather.find(x=>x.team===team);
  const d = def.find(x=>x.team===p.opp || x.team===oppOf(team, odds)) || {};
  const align = await fetchRouteAlign(p.player_id, season);

  // script adjusts pass/run expectation a bit
  const scriptBoost = o ? scriptAdj(o.spread, o.total, p.position) : 0;
  // coverage adjust for WR/TE by alignment vs defense splits
  const coverAdj = coverAdjustment(p.position, align, d);
  // weather penalty mainly for passing (wind)
  const weatherAdj = w ? weatherAdjustment(w.wind_mph, p.position) : 0;

  return {
    scriptBoost, coverAdj, weatherAdj,
    deltaFloor: Math.min(1.5, coverAdj*0.2 - Math.max(0, weatherAdj)*0.1),
    deltaCeil:  Math.max(-1.0, coverAdj*0.4 - Math.max(0, weatherAdj)*0.1)
  };
}

function scriptAdj(spread:number, total:number, pos:'QB'|'RB'|'WR'|'TE') {
  // simple: big underdog → pass bump; big favorite → RB bump
  const underdog = spread > 3 ? 1 : spread < -3 ? -1 : 0;
  if (pos==='QB' || pos==='WR' || pos==='TE') return underdog * 0.6; // ~+0.6 pts if decent dog
  if (pos==='RB') return (underdog===-1 ? 0.5 : -0.2);               // favs feed RBs
  return 0;
}
function coverAdjustment(pos:string, a:{slot_pct:number,outside_pct:number,inline_pct:number}, d:any) {
  if (pos==='WR') {
    const slot = (d.vs_wr_slot_ppg ?? 12) - 12;     // relative to league avg ~12
    const outside = (d.vs_wr_outside_ppg ?? 12) - 12;
    return slot*a.slot_pct + outside*a.outside_pct; // points differential
  }
  if (pos==='TE') return (d.vs_te_ppg ?? 9) - 9;
  if (pos==='RB') return (d.vs_rb_recv_ppg ?? 7) - 7; // pass-game RBs
  return 0;
}
function weatherAdjustment(wind:number, pos:string) {
  if (wind==null) return 0;
  if (wind >= 20 && (pos==='QB'||pos==='WR'||pos==='TE')) return -1.5;
  if (wind >= 15 && (pos==='QB'||pos==='WR'||pos==='TE')) return -0.8;
  return 0;
}
function adjustedMu(adj:any){ return 0 + adj.scriptBoost + adj.coverAdj + adj.weatherAdj; /* added to existing expected_points in builder */ }
function confidenceFromRanges(aF:number,aC:number,bF:number,bC:number) {
  const spread = ((aC-aF)+(bC-bF))/2;
  return Math.max(40, Math.min(90, 85 - spread*3));
}
function view(p:any, mu:number, floor:number, ceil:number) {
  return {
    player_id:p.player_id, name:p.name, team:p.team, pos:p.position,
    power:p.power_score, rag:p.rag_color, rag_score:p.rag_score,
    expected_points: Number(((p.expected_points??0) + mu).toFixed(1)),
    floor_points: Number(((p.floor_points??0) + (floor - (mu))).toFixed(1)),
    ceiling_points: Number(((p.ceiling_points??0) + (ceil - (mu))).toFixed(1)),
    delta_vs_ecr: p.delta_vs_ecr, upside_index: p.upside_index
  };
}
function buildReasons(A:any,B:any,aAdj:any,bAdj:any,aMu:number,bMu:number) {
  const R:string[] = [];
  // Show matchup/script/weather for both
  const who = (aMu > bMu) ? `${A.name} over ${B.name}` : `${B.name} over ${A.name}`;
  const edge = Math.abs(aMu-bMu).toFixed(1);
  R.push(`Edge: ${who} by ${edge} expected points (after script/coverage/weather).`);
  if (Math.abs(aAdj.coverAdj) > 0.3) R.push(`${A.name}: coverage adj ${aAdj.coverAdj.toFixed(1)} | ${B.name}: ${bAdj.coverAdj.toFixed(1)}`);
  if (Math.abs(aAdj.scriptBoost) > 0 || Math.abs(bAdj.scriptBoost) > 0) R.push(`Script: A ${fmt(aAdj.scriptBoost)}, B ${fmt(bAdj.scriptBoost)}`);
  if (Math.abs(aAdj.weatherAdj) > 0 || Math.abs(bAdj.weatherAdj) > 0) R.push(`Weather: A ${fmt(aAdj.weatherAdj)}, B ${fmt(bAdj.weatherAdj)}`);
  if ((A.delta_vs_ecr ?? 0) >= 10 || (B.delta_vs_ecr ?? 0) >= 10)
    R.push(`Market delta: A ${A.delta_vs_ecr ?? 0}, B ${B.delta_vs_ecr ?? 0} (we’re earlier = edge).`);
  return R.slice(0,4);
}
function fmt(x:number){ return (x>=0?'+':'')+x.toFixed(1)+' pts'; }
function oppOf(team:string, odds:any[]){ const row = odds.find(x=>x.team===team); return row?.opp; }


Note: adjustedMu() currently returns only the adjustments. Add it to your existing expected_points (f.expected_points) when rendering. Keep weights small and validate.

4) Output shape (what users see)
{
  "verdict": "Start Smith",
  "confidence": 72,
  "reasons": [
    "Edge: DeVonta Smith over Jerry Jeudy by 1.6 expected points (after script/coverage/weather).",
    "Coverage adj Smith +0.9 vs Jeudy +0.1",
    "Script: A +0.4 pts, B -0.2 pts",
    "Market delta: A +11, B +2 (we're earlier on Smith)"
  ],
  "headToHead": {
    "A": {"name":"Jerry Jeudy","pos":"WR","expected_points":13.4,"floor_points":9.1,"ceiling_points":18.2,"rag":"AMBER"},
    "B": {"name":"DeVonta Smith","pos":"WR","expected_points":15.0,"floor_points":10.0,"ceiling_points":20.4,"rag":"GREEN"},
    "delta_mu": 1.6
  },
  "tone": "tiber"
}

5) Why this fixes your list of problems

Analyzes both players (not single-player).

Comparative logic: explicit delta_mu, floor/ceiling, risk, upside preference.

Matchup intel: coverage alignment vs defense, script (spread/total), weather, QB stability already in your facts.

Explanatory depth: bullets are numeric and specific, not attitude.

6) Do-this-now (so Joe can click it)

Add routes + compare.ts above.

Stub vegas/weather/defenseSplits/alignments (wire real feeds later).

Frontend: add a “Compare” modal that hits /api/voice/compare with two names/ids.

Validate on a few WR/WR, RB/RB matchups; tune scriptAdj & coverAdjustment constants.

Strong take: once this lands, Tiber stops being a lookup and starts being a decision engine. That’s the whole point.