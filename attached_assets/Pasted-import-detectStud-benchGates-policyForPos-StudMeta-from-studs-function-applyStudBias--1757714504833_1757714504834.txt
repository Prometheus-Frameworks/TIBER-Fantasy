import { detectStud, benchGates, policyForPos, StudMeta } from "./studs";

function applyStudBias(
  aInput: PlayerInput, aMeta: StudMeta | undefined,
  bInput: PlayerInput, bMeta: StudMeta | undefined,
  aScore: number, bScore: number
) {
  // Returns possibly adjusted totals and SYS notes
  const notes: string[] = [];

  const aDet = aMeta ? detectStud(aInput.position, aMeta) : null;
  const bDet = bMeta ? detectStud(bInput.position, bMeta) : null;

  // early exit if neither is stud/bubble
  if (!aDet?.isStud && !bDet?.isStud && !aDet?.isBubble && !bDet?.isBubble) {
    return { aTotal: aScore, bTotal: bScore, notes };
  }

  const aGates = aDet ? benchGates(aInput, aInput.impliedTeamTotal) : { gate:false, reasons:[] };
  const bGates = bDet ? benchGates(bInput, bInput.impliedTeamTotal) : { gate:false, reasons:[] };

  const aPol = policyForPos(aInput.position);
  const bPol = policyForPos(bInput.position);

  let A = aScore, B = bScore;

  // Hard lock: if stud and not gated, prefer stud unless projection gap is massive
  const bigGap = Math.abs(aScore - bScore) >= Math.max(aPol.marginFloor, bPol.marginFloor) + 6;

  if (aDet?.isStud && !aGates.gate) {
    A += aPol.leanBump;
    notes.push(`${aInput.name}: Start Your Studs bias (+${aPol.leanBump.toFixed(1)})`);
    if (aPol.clearLock && !bigGap) {
      // lift A slightly to cross margin floor if close
      const need = Math.max(0, aPol.marginFloor - (A - B));
      if (need > 0) { A += need + 0.1; notes.push(`${aInput.name}: SYS lock (margin floor ${aPol.marginFloor})`); }
    }
  }
  if (bDet?.isStud && !bGates.gate) {
    B += bPol.leanBump;
    notes.push(`${bInput.name}: Start Your Studs bias (+${bPol.leanBump.toFixed(1)})`);
    if (bPol.clearLock && !bigGap) {
      const need = Math.max(0, bPol.marginFloor - (B - A));
      if (need > 0) { B += need + 0.1; notes.push(`${bInput.name}: SYS lock (margin floor ${bPol.marginFloor})`); }
    }
  }

  // If a stud is gated, record it
  if (aDet?.isStud && aGates.gate) notes.push(`${aInput.name}: stud gated — ${aGates.reasons.join("; ")}`);
  if (bDet?.isStud && bGates.gate) notes.push(`${bInput.name}: stud gated — ${bGates.reasons.join("; ")}`);

  return { aTotal: Number(A.toFixed(2)), bTotal: Number(B.toFixed(2)), notes };
}