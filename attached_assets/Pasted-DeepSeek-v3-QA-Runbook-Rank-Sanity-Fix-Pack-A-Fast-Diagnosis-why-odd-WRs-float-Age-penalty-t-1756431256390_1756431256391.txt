DeepSeek v3 – QA Runbook + Rank-Sanity Fix Pack
A) Fast Diagnosis (why odd WRs float)

Age penalty too soft / missing in v3 service.

Nulls treated as neutral (50-ish) → older players with thin data aren’t penalized.

Role computed without a recent-usage floor (routes/targets) → stale usage looks fine.

Roster status not enforced (FA/PS/suspended) → shouldn’t rank near starters.

ADP gaps not used as a sanity check (optionally limit absurd deltas).

B) Config Patch (drop into /config/deepseek.v3.weights.json)

Use firmer guardrails and explicit veteran decay:

{
  "version": "3.0.1",
  "mode_defaults": {
    "dynasty": { "talent": 0.30, "role": 0.16, "context": 0.14, "durability": 0.10, "recency": 0.08, "spike": 0.08, "risk": 0.14 },
    "redraft": { "talent": 0.22, "role": 0.28, "context": 0.16, "durability": 0.08, "recency": 0.18, "spike": 0.06, "risk": 0.02 }
  },
  "tier_cutoffs": [96, 91, 86, 81, 76, 71],
  "guards": {
    "dry_run": true,
    "max_players": 1200,
    "require_sleeper_sync_ok": true,
    "allow_enrichment": true,
    "min_recent_routes": 40,
    "min_recent_targets": 10,
    "drop_if_status": ["FA","SUS","PUP","RES","RET"],
    "adp_delta_cap": 40,
    "null_default_floor": 20
  },
  "age_curves": {
    "WR": [[24,0],[26,0],[28,0],[30,-4],[31,-7],[32,-10],[33,-14],[34,-18],[35,-22]],
    "RB": [[24,0],[25,0],[26,-3],[27,-6],[28,-10],[29,-14],[30,-20]],
    "TE": [[25,0],[27,0],[29,0],[31,-3],[32,-6],[33,-9],[34,-12]],
    "QB": [[28,0],[32,0],[34,-2],[36,-4],[38,-7]]
  }
}

C) Service Tweaks (targeted, safe)

In deepseekV3Service.ts:

Harden null handling (floor, not neutral)

const nz = (n:number|undefined|null, floor=weights.guards.null_default_floor)=> (n==null? floor : n);


Age curve penalty

function agePenalty(pos:string, age?:number){
  if (!age) return 0;
  const curve = weights.age_curves[pos] || [];
  // pick the largest age <= current
  let pen = 0;
  for (const [a,p] of curve) if (age >= a) pen = p;
  return pen; // negative numbers like -14
}


Roster/status filter & recent-usage floor
(Apply before scoring)

function isDroppableStatus(s?:string){
  const bad = new Set(weights.guards.drop_if_status);
  return s && bad.has(s.toUpperCase());
}

function recentUsageOK(p:V3Input){
  const routes = nz(p.routeRate ?? 0)*100; // if routeRate is 0..1
  const tgts = nz(p.tgtShare ?? 0)*100;
  return (routes >= weights.guards.min_recent_routes) || (tgts >= weights.guards.min_recent_targets);
}


Compute pieces with floors

function computeRole(p:V3Input):number{
  if (!recentUsageOK(p)) return 20; // clamp low if no recent role
  const r = (nz(p.routeRate)*100)*0.4 + (nz(p.tgtShare)*100)*0.4 + (nz(p.rzTgtShare)*100)*0.2;
  const rb = (nz(p.rushShare)*100)*0.6 + (nz(p.glRushShare)*100)*0.4;
  if (p.pos==="RB") return clamp(rb);
  if (p.pos==="TE") return clamp(r*0.95);
  return clamp(r);
}

function computeTalent(p:V3Input):number{
  const t = nz(p.talentScore)*0.7 + nz(p.explosiveness)*0.2 + nz(p.yakPerRec)*0.1;
  return clamp(t);
}

function computeRecency(p:V3Input):number{
  // prefer last-6w perf; if missing, don’t let it buoy the player
  return clamp(nz(p.last6wPerf, 25));
}

function computeRisk(p:V3Input):number{
  const cap = 100 - nz(p.draftCapTier, 50);
  return clamp(0.6*cap + 0.4*nz(p.injuryRisk, 20)); // higher=more risk
}

function computeDurability(p:V3Input, pos:string):number{
  const base = 100 - nz(p.injuryRisk, 20)*1.2 + agePenalty(pos, p.age);
  return clamp(base);
}


Score + sanity caps

// after computing all components:
let score = (
  talentScore * cfg.talent +
  roleScore   * cfg.role +
  contextScore* cfg.context +
  durabilityScore*cfg.durability +
  recencyScore*cfg.recency +
  spikeScore  * cfg.spike -
  riskScore   * cfg.risk
);
// light global clamp to avoid outliers from sparse data
if (!recentUsageOK(p)) score = Math.min(score, 55);


ADP delta clamp (optional)
When joining ADP, after computing ranks:

if (weights.guards.adp_delta_cap && r.adp){
  const delta = Math.round((r.adp - r.rank)*10)/10;
  r.delta_vs_adp = Math.max(Math.min(delta, weights.guards.adp_delta_cap), -weights.guards.adp_delta_cap);
}


Filter at intake
Before scoring loop:

const pool = (await getAllPlayers())
  .filter(p => !isDroppableStatus((p as any).status)) // integrate your status field
  .slice(0, weights.guards.max_players);

D) Quick QA Script (server eye-test)

Aging WR sanity (no Lockett at WR7)

curl -s "/api/rankings/deepseek/v3?mode=redraft" | jq '
  .data
  | map(select(.pos=="WR"))[:25]
  | map(.name+" ("+(.age|tostring)+") - "+(.score|tostring))'


Pass: Top WRs are 22–30 heavy; 32+ appear later.

Dynasty vs Redraft divergence

R1=$(curl -s "/api/rankings/deepseek/v3?mode=redraft")
D1=$(curl -s "/api/rankings/deepseek/v3?mode=dynasty")
python - <<'PY'
import json,sys
R=json.loads("""$R1""")["data"]; D=json.loads("""$D1""")["data"]
idxR={r["player_id"]:r["rank"] for r in R[:200]}
for d in D[:50]:
  ridx = idxR.get(d["player_id"])
  if ridx: print(f'{d["name"]:24} DY#{d["rank"]:>3}  RD#{ridx:>3}')
PY


Pass: Younger studs rise in dynasty relative to redraft.

Tier sanity (no single-player weird tiers in top 50)

curl -s "/api/rankings/deepseek/v3?mode=redraft" | jq '
  .data[:50] | group_by(.tier) | map({tier: .[0].tier, count: length})'


Pass: No tier with count=1 unless a true outlier.

Roster/status filter check
(Replace with your field: .status)

curl -s "/api/rankings/deepseek/v3?mode=redraft" | jq '
  .data | map(select(.status=="FA" or .status=="SUS" or .status=="PUP")) | length'


Pass: 0

Performance

time curl -s "/api/rankings/deepseek/v3?mode=redraft" >/dev/null


Pass: p50 < 300ms (warm cache).

E) Acceptance Criteria (copy for the PR)

No player with status ∈ {FA,SUS,PUP,RES,RET} appears in the top 150.

WR age ≥ 33 cannot appear in top 12 redraft unless recent usage floor is met.

Dynasty vs redraft ordering shows meaningful differences for young/old.

Top-25 per position shows varied scores (no clustering from nulls).

API p50 < 300ms; JSON schema intact; ranks strictly 1..N.

F) If something still looks off

Log per-player component breakdown for the top 50 (talent/role/context/durability/recency/spike/risk) to spot which component is propping them up.

Verify inputs: recent routes/targets and age are actually populated for those outliers.

If Sleeper leaves someone “unknown,” force null → floor (20), not neutral.