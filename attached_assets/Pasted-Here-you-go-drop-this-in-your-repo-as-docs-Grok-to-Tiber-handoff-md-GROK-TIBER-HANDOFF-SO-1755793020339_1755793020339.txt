Here you go — drop this in your repo as:

docs/Grok-to-Tiber-handoff.md

⸻

GROK → TIBER HANDOFF: SOSv1 Integration

Objective: Replace seed-based SOS with real data. Wire Grok’s CSV outputs (or DB tables) into the API so /sos renders live scores immediately.

⸻

TL;DR (what you’re doing right now)
	1.	Run Grok’s script for a populated year (e.g., 2024).
	2.	Load CSVs into Postgres (schedule, defense_dvp).
	3.	Add last4_avg column + indexes (migration below).
	4.	Swap sos.service.ts to query DB and compute scores.
	5.	Hit /api/sos/weekly?position=RB&week=1 — see green/yellow/red.

Ship it.

⸻

0) Paths to touch (exact)
	•	server/src/modules/sos/sos.service.ts (replace with DB-backed version)
	•	server/src/modules/sos/sos.controller.ts (no change except imports)
	•	server/src/modules/sos/sos.router.ts (already mounted at /api/sos)
	•	server/src/db/migrations/20250821_add_sos_last4_indexes.sql (new)
	•	server/src/db/knex.ts (if you don’t already have a Knex instance)

If you’re not on Knex, use the node-postgres fallback snippet at the bottom.

⸻

1) Run Grok’s loader (local dev sanity)

# inside data-pipes or scripts dir
python sos_ingest.py --year 2024   # Grok’s script name/path; adjust if different
# Outputs: defense_dvp_2024.csv, schedule_2024.csv, dvp_rolling_2024.csv


⸻

2) Load CSVs → Postgres

After the base migration that created defense_dvp and schedule:

-- From psql shell in your DB
\COPY defense_dvp(season, week, def_team, position, fp_allowed)
  FROM 'defense_dvp_2024.csv' DELIMITER ',' CSV HEADER;

\COPY schedule(season, week, home, away)
  FROM 'schedule_2024.csv' DELIMITER ',' CSV HEADER;


⸻

3) Migration: add last4_avg + helpful indexes

Create server/src/db/migrations/20250821_add_sos_last4_indexes.sql

-- Add last4_avg to defense_dvp so we can store Grok’s trailing average
ALTER TABLE defense_dvp
  ADD COLUMN IF NOT EXISTS last4_avg NUMERIC;

-- Optional backfill from dvp_rolling_2024.csv if you import it to a temp table.
-- Otherwise we’ll compute last4 on the fly in service (but column is superior for perf).

-- Indexes for fast filters
CREATE INDEX IF NOT EXISTS idx_defense_dvp_season_pos_week
  ON defense_dvp(season, position, week);
CREATE INDEX IF NOT EXISTS idx_defense_dvp_team_pos
  ON defense_dvp(def_team, position);

CREATE INDEX IF NOT EXISTS idx_schedule_season_week
  ON schedule(season, week);

Run your migrations as usual.

⸻

4) Knex instance (if missing)

server/src/db/knex.ts

import knex, { Knex } from 'knex';

export const db: Knex = knex({
  client: 'pg',
  connection: process.env.DATABASE_URL || {
    host: process.env.PGHOST || '127.0.0.1',
    port: +(process.env.PGPORT || 5432),
    user: process.env.PGUSER || 'postgres',
    password: process.env.PGPASSWORD || '',
    database: process.env.PGDATABASE || 'otc'
  },
  pool: { min: 0, max: 10 }
});

ENV required if not already set: PGHOST, PGPORT, PGUSER, PGPASSWORD, PGDATABASE (or a single DATABASE_URL).

⸻

5) Replace sos.service.ts with DB-backed logic

server/src/modules/sos/sos.service.ts

import { db } from '../../db/knex';

export type Position = 'RB'|'WR'|'QB'|'TE';

export interface DVPRow {
  season: number;
  week: number;
  def_team: string;
  position: Position;
  fp_allowed: number;
  last4_avg?: number | null;
}

export interface ScheduleRow {
  season: number;
  week: number;
  home: string;
  away: string;
}

export interface WeeklySOS {
  team: string;
  position: Position;
  week: number;
  opponent: string;
  sos_score: number; // 0-100 higher = easier
  tier: 'green'|'yellow'|'red';
}

/** Opinionated v1 weights */
const RECENCY_WEIGHT = 0.6;  // last4
const SEASON_WEIGHT  = 0.4;  // season avg
const DEFAULT_SEASON = 2024; // until 2025 games exist

function toTier(score: number): 'green'|'yellow'|'red' {
  if (score >= 67) return 'green';
  if (score >= 33) return 'yellow';
  return 'red';
}

/** Percentile scaling 0..100 */
function percentileScale(values: number[], v: number): number {
  if (!values.length) return 50;
  const sorted = [...values].sort((a,b)=>a-b);
  // Position of v (inclusive rank)
  let rank = 0;
  for (let i=0;i<sorted.length;i++) {
    if (v >= sorted[i]) rank = i + 1;
    else break;
  }
  return Math.round((rank / sorted.length) * 100);
}

/** Season avg per defense/position up to given week (inclusive) */
async function getSeasonAvg(season: number, position: Position, week: number) {
  const rows = await db('defense_dvp')
    .select('def_team')
    .avg({ season_avg: 'fp_allowed' })
    .where({ season, position })
    .andWhere('week', '<=', week)
    .groupBy('def_team');

  const map = new Map<string, number>();
  rows.forEach(r => map.set(r.def_team, Number(r.season_avg)));
  return map;
}

/** Last4 average per defense/position at given week (already precomputed if column exists) */
async function getLast4(season: number, position: Position, week: number) {
  // Prefer explicit last4_avg column if stored at week row.
  // If not present for this week, we can compute with a subquery.
  const rows: {def_team:string; last4_avg:number|null}[] = await db
    .select('def_team', 'last4_avg')
    .from('defense_dvp')
    .where({ season, position, week });

  const map = new Map<string, number>();
  if (rows.length && rows.some(r => r.last4_avg !== null)) {
    rows.forEach(r => {
      if (r.last4_avg !== null) map.set(r.def_team, Number(r.last4_avg));
    });
    return map;
  }

  // Fallback: compute trailing prev 4 weeks
  const fallbacks = await db('defense_dvp as d')
    .select('d.def_team')
    .avg<{def_team:string; last4:number}>({ last4: 'd2.fp_allowed' })
    .joinRaw(`
      JOIN defense_dvp d2
      ON d2.season = d.season
      AND d2.position = d.position
      AND d2.def_team = d.def_team
      AND d2.week BETWEEN ? AND ?
    `, [week - 4, week - 1])
    .where('d.season', season)
    .andWhere('d.position', position)
    .andWhere('d.week', week)
    .groupBy('d.def_team');

  fallbacks.forEach(r => map.set(r.def_team, Number(r.last4)));
  return map;
}

/** All games for week */
async function getWeekGames(season: number, week: number): Promise<ScheduleRow[]> {
  return db('schedule')
    .select('season', 'week', 'home', 'away')
    .where({ season, week });
}

/** Build weekly SOS for a position */
export async function computeWeeklySOS(position: Position, week: number, season = DEFAULT_SEASON): Promise<WeeklySOS[]> {
  const games = await getWeekGames(season, week);
  if (!games.length) return [];

  const seasonAvg = await getSeasonAvg(season, position, week);
  const last4 = await getLast4(season, position, week);

  // pool of "easiness candidates" for percentile scaling
  const easinessPool: number[] = [];

  // Map opponent defense -> blended ease proxy
  const defEase = new Map<string, number>();
  const defTeams = new Set<string>();
  games.forEach(g => { defTeams.add(g.home); defTeams.add(g.away); });

  // We need all defenses in the slate (as opponents)
  const defenses = new Set<string>();
  games.forEach(g => { defenses.add(g.home); defenses.add(g.away); });

  // Build a table of defense -> blended FP allowed proxy
  defenses.forEach(team => {
    const sAvg = seasonAvg.get(team);
    const l4 = last4.get(team);
    const blended =
      (l4 != null && !isNaN(l4) ? RECENCY_WEIGHT * l4 : 0) +
      (sAvg != null && !isNaN(sAvg) ? SEASON_WEIGHT * sAvg : 0);

    if (!isNaN(blended) && blended > 0) {
      defEase.set(team, blended);
      easinessPool.push(blended);
    }
  });

  // If pool is empty (early season, missing data), bail gracefully
  if (!easinessPool.length) return [];

  const rows: WeeklySOS[] = [];
  for (const g of games) {
    // Home offense vs away defense
    const awayDef = g.away;
    const homeEaseRaw = defEase.get(awayDef);
    if (homeEaseRaw != null) {
      const score = percentileScale(easinessPool, homeEaseRaw);
      rows.push({
        team: g.home,
        position,
        week,
        opponent: awayDef,
        sos_score: score,
        tier: toTier(score)
      });
    }

    // Away offense vs home defense
    const homeDef = g.home;
    const awayEaseRaw = defEase.get(homeDef);
    if (awayEaseRaw != null) {
      const score = percentileScale(easinessPool, awayEaseRaw);
      rows.push({
        team: g.away,
        position,
        week,
        opponent: homeDef,
        sos_score: score,
        tier: toTier(score)
      });
    }
  }

  return rows;
}

/** Simple ROS: average of next N weeks */
export async function computeROSSOS(position: Position, startWeek = 1, window = 5, season = DEFAULT_SEASON) {
  const weeks = Array.from({length: window}, (_,i) => startWeek + i);
  const all: WeeklySOS[] = [];
  for (const w of weeks) {
    const wk = await computeWeeklySOS(position, w, season);
    all.push(...wk);
  }
  const byTeam = new Map<string, WeeklySOS[]>();
  all.forEach(r => {
    const k = `${r.team}:${position}`;
    if (!byTeam.has(k)) byTeam.set(k, []);
    byTeam.get(k)!.push(r);
  });

  return Array.from(byTeam.entries()).map(([k, arr]) => {
    const [team] = k.split(':');
    const avg = Math.round(arr.reduce((a,b)=>a+b.sos_score, 0) / arr.length);
    return { team, position, weeks, avg_score: avg, tier: toTier(avg) };
  }).sort((a,b)=>b.avg_score - a.avg_score);
}

Notes:
	•	Default season set to 2024 until 2025 has games.
	•	If last4_avg isn’t stored for a given week, we compute it on the fly (slower; acceptable for v1).

⸻

6) Controller stays the same (params → service)

server/src/modules/sos/sos.controller.ts

import { Request, Response } from 'express';
import { computeWeeklySOS, computeROSSOS } from './sos.service';
import type { Position } from './sos.service';

export const getWeekly = async (req: Request, res: Response) => {
  const position = (req.query.position as Position) || 'RB';
  const week = parseInt((req.query.week as string) || '1', 10);
  const season = parseInt((req.query.season as string) || '2024', 10);
  const data = await computeWeeklySOS(position, week, season);
  res.json({ position, week, season, items: data });
};

export const getROS = async (req: Request, res: Response) => {
  const position = (req.query.position as Position) || 'RB';
  const startWeek = parseInt((req.query.startWeek as string) || '1', 10);
  const window = parseInt((req.query.window as string) || '5', 10);
  const season = parseInt((req.query.season as string) || '2024', 10);
  const data = await computeROSSOS(position, startWeek, window, season);
  res.json({ position, startWeek, window, season, items: data });
};


⸻

7) Quick endpoints to test
	•	GET /api/sos/weekly?position=RB&week=1&season=2024
	•	GET /api/sos/ros?position=RB&startWeek=1&window=5&season=2024

Expected: JSON array with teams, opponents, 0–100 scores, tiers.

⸻

8) Frontend (no changes required for v1)

/sos page and table will render as-is. If you added a season select, pass &season=2024 into the fetch URL.

⸻

9) Optional: import rolling CSV to persist last4_avg

If you decide to load Grok’s dvp_rolling_2024.csv:

CREATE TEMP TABLE dvp_rolling_tmp (
  season INT,
  week INT,
  def_team TEXT,
  position TEXT,
  fp_allowed NUMERIC,
  last4_avg NUMERIC
);

\COPY dvp_rolling_tmp FROM 'dvp_rolling_2024.csv' DELIMITER ',' CSV HEADER;

UPDATE defense_dvp d
SET last4_avg = r.last4_avg
FROM dvp_rolling_tmp r
WHERE d.season = r.season
  AND d.week = r.week
  AND d.def_team = r.def_team
  AND d.position = r.position;

DROP TABLE dvp_rolling_tmp;

This makes recency fast and deterministic.

⸻

10) Commit message template

feat(SOS): wire Grok data -> live SOS API

- load defense_dvp & schedule from Grok CSVs (2024)
- add last4_avg column + indexes
- replace sos.service to query DB and blend recency/season
- keep controller/routes stable; frontend /sos renders live


⸻

Node‑Postgres fallback (if not using Knex)

Replace the imports at the top of sos.service.ts:

import { Pool } from 'pg';
const pool = new Pool({ connectionString: process.env.DATABASE_URL /* or PGHOST/etc */ });

async function q<T = any>(text: string, params: any[] = []): Promise<T[]> {
  const c = await pool.connect();
  try {
    const r = await c.query(text, params);
    return r.rows as T[];
  } finally {
    c.release();
  }
}

Then rewrite the three DB helpers roughly as:

async function getSeasonAvg(season:number, position:Position, week:number) {
  const rows = await q<{def_team:string; season_avg:string}>(
    `SELECT def_team, AVG(fp_allowed) AS season_avg
     FROM defense_dvp
     WHERE season=$1 AND position=$2 AND week <= $3
     GROUP BY def_team`, [season, position, week]);
  const map = new Map<string, number>();
  rows.forEach(r => map.set(r.def_team, Number(r.season_avg)));
  return map;
}

async function getLast4(season:number, position:Position, week:number) {
  const rows = await q<{def_team:string; last4_avg:number|null}>(
    `SELECT def_team, last4_avg
     FROM defense_dvp
     WHERE season=$1 AND position=$2 AND week=$3`, [season, position, week]);
  const map = new Map<string, number>();
  if (rows.some(r => r.last4_avg !== null)) {
    rows.forEach(r => { if (r.last4_avg != null) map.set(r.def_team, Number(r.last4_avg)); });
    return map;
  }
  const fb = await q<{def_team:string; last4:string}>(
    `SELECT d.def_team, AVG(d2.fp_allowed) AS last4
     FROM defense_dvp d
     JOIN defense_dvp d2
       ON d2.season=d.season
      AND d2.position=d.position
      AND d2.def_team=d.def_team
      AND d2.week BETWEEN $1 AND $2
     WHERE d.season=$3 AND d.position=$4 AND d.week=$5
     GROUP BY d.def_team`,
     [week-4, week-1, season, position, week]);
  fb.forEach(r => map.set(r.def_team, Number(r.last4)));
  return map;
}

async function getWeekGames(season:number, week:number) {
  return q<ScheduleRow>(
    `SELECT season, week, home, away FROM schedule WHERE season=$1 AND week=$2`,
    [season, week]
  );
}

Everything else in sos.service.ts stays the same.

⸻

Done criteria (for you to check off)
	•	/api/sos/weekly returns non-empty data for season=2024
	•	Scores vary by opponent and show tiers (green/yellow/red)
	•	/sos page renders without seed, purely from DB
	•	Switching week updates results instantly
	•	(Optional) last4_avg populated and used

⸻

Notes / Gotchas
	•	Early season (weeks 1–3) will have thin history → last4 may be sparse. The service handles it; season average will carry the weight until data builds.
	•	If 2025 is selected before games are played, endpoint will return empty arrays — that’s fine. Default to 2024 in UI until Week 1 kicks.

⸻

That’s the handoff. Copy this file to the repo, follow the boxes, and the SOS page goes live off Grok’s data. If anything throws, ping me with the exact error and I’ll patch fast.