// server/index.ts
import express, { type Request, type Response, type NextFunction } from "express";
import path from "node:path";
import fs from "node:fs";
import { attachSignatureHeader } from "./middleware/signature";
import { registerRoutes } from "./routes"; // your existing route registrar

// dumb logger helper so we don't pull extra deps
const log = (...args: any[]) => console.log(...args);

const app = express();

// ---- core middleware ----
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(attachSignatureHeader);

// ---- tiny API logger (only /api/*) ----
app.use((req, res, next) => {
  const start = Date.now();
  const pathStr = req.path;
  let captured: unknown;

  const origJson = res.json.bind(res);
  // @ts-expect-error preserve original signature
  res.json = (body: unknown, ...args: unknown[]) => {
    captured = body;
    // @ts-expect-error forward
    return origJson(body, ...args);
  };

  res.on("finish", () => {
    if (!pathStr.startsWith("/api")) return;
    const ms = Date.now() - start;
    let line = `${req.method} ${pathStr} ${res.statusCode} in ${ms}ms`;
    try {
      if (captured) line += ` :: ${JSON.stringify(captured)}`;
    } catch {/* ignore */}
    if (line.length > 160) line = line.slice(0, 159) + "â€¦";
    log(line);
  });

  next();
});

// simple health
app.get("/health", (_req, res) => res.json({ ok: true }));

(async () => {
  log("ðŸš€ Starting Tiber Fantasy â€“ quick boot");

  // 1) Mount your API routes
  const maybeServer = await registerRoutes(app);

  // 2) Error handler (after routes)
  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err?.status ?? err?.statusCode ?? 500;
    res.status(status).json({ message: err?.message ?? "Internal Server Error" });
    console.error("Unhandled error:", err);
  });

  // 3) Dev vs Prod assets
  const isDev = process.env.NODE_ENV === "development";

  if (isDev) {
    // DEV-ONLY: dynamically import Vite so esbuild can drop it from the prod bundle
    try {
      const { setupVite } = await import("./vite");
      await setupVite(app, maybeServer);
      log("âš¡ Vite dev middleware mounted");
    } catch (e) {
      console.warn("Vite dev setup failed (continuing):", e);
    }
  } else {
    // PROD: serve static files from dist/public if present, no import.meta needed
    const publicDir = path.resolve(process.cwd(), "dist", "public");
    if (fs.existsSync(publicDir)) {
      app.use(express.static(publicDir));
      log(`ðŸ—‚ï¸  Serving static assets from ${publicDir}`);
    } else {
      log("â„¹ï¸  No dist/public directory found; serving API only");
    }
  }

  // 4) Listen on Render port (or 5000 for local)
  const PORT = Number(process.env.PORT ?? 5000);
  const HOST = "0.0.0.0";

  const httpListener: { listen: (...args: any[]) => any } =
    (maybeServer as any)?.listen ? (maybeServer as any) : (app as any);

  httpListener.listen(
    { port: PORT, host: HOST, reusePort: true } as any,
    () => log(`[express] serving on port ${PORT}`)
  );

  // ---- OPTIONAL: background jobs later (keep commented until needed) ----
  // setImmediate(async () => {
  //   try {
  //     const { sleeperSyncService } = await import("./services/sleeperSyncService");
  //     await sleeperSyncService.syncPlayers();
  //     log("âœ… Sleeper sync booted");
  //   } catch (e) {
  //     console.warn("Sleeper sync skipped:", e);
  //   }
  // });
})();
