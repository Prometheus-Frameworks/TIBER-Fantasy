import express, { Request, Response } from 'express';
import axios from 'axios';
import cheerio from 'cheerio';
import cron from 'node-cron';
import Fuse from 'fuse.js';
import fs from 'fs'; // For fallback JSON load

const app = express();
app.use(express.json());

interface PlayerProjection {
  player_name: string;
  position: string;
  team: string;
  projected_fpts: number;
  receptions?: number;
  birthdate?: string;
}

interface LeagueSettings {
  format: 'standard' | 'ppr' | 'half-ppr';
  num_teams: number;
  starters: { QB: number; RB: number; WR: number; TE: number; FLEX: number };
  is_superflex: boolean;
  is_te_premium: boolean;
}

// In-memory cache
const cache = { projections: null as PlayerProjection[] | null, lastFetch: 0 };
const CACHE_TTL = 60 * 60 * 1000; // 1 hour

// Fetch and aggregate projections
async function fetchAggregatedProjections(): Promise<PlayerProjection[]> {
  if (cache.projections && Date.now() - cache.lastFetch < CACHE_TTL) return cache.projections;

  const sources = [
    { url: 'https://fantasy.espn.com/football/players/projections', parser: parseESPN },
    { url: 'https://www.draftsharks.com/rankings', parser: parseDraftSharks },
  ];

  let allProjections: { [key: string]: { fpts: number[]; pos: string; team: string; recs: number[]; birthdate?: string } } = {};

  for (const source of sources) {
    try {
      const { data } = await axios.get(source.url);
      const $ = cheerio.load(data);
      const projections = source.parser($);
      projections.forEach((p: PlayerProjection) => {
        const key = `${p.player_name.toLowerCase()}-${p.position.toLowerCase()}`;
        if (!allProjections[key]) allProjections[key] = { fpts: [], pos: p.position, team: p.team, recs: [], birthdate: p.birthdate };
        allProjections[key].fpts.push(p.projected_fpts);
        if (p.receptions) allProjections[key].recs.push(p.receptions);
      });
    } catch (error) {
      console.error(`Fetch error from ${source.url}:`, error);
    }
  }

  const aggregated = Object.entries(allProjections).map(([key, val]) => {
    const [name, pos] = key.split('-');
    const avgFpts = val.fpts.reduce((sum, f) => sum + f, 0) / val.fpts.length || 0;
    const avgRecs = val.recs.reduce((sum, r) => sum + r, 0) / val.recs.length || 0;
    return { player_name: name, position: pos.toUpperCase(), team: val.team, projected_fpts: avgFpts, receptions: avgRecs, birthdate: val.birthdate };
  });

  const fuse = new Fuse(aggregated, { keys: ['player_name', 'position'], threshold: 0.3 });
  const unique = aggregated.filter((p, i) => {
    const matches = fuse.search({ player_name: p.player_name, position: p.position }).filter(m => m.refIndex !== i);
    if (matches.length) {
      matches.forEach(m => {
        aggregated[m.refIndex].projected_fpts = (aggregated[m.refIndex].projected_fpts + p.projected_fpts) / 2;
      });
      return false;
    }
    return true;
  });

  cache.projections = unique;
  cache.lastFetch = Date.now();
  return unique;
}

// Parsers (simplified)
function parseESPN($: cheerio.Root): PlayerProjection[] {
  // Implement based on site structure
  return []; // Placeholder - fill with actual parsing
}

function parseDraftSharks($: cheerio.Root): PlayerProjection[] {
  // Implement based on site structure
  return []; // Placeholder - fill with actual parsing
}

// Fallback if fetch fails
function loadFallbackProjections(): PlayerProjection[] {
  return JSON.parse(fs.readFileSync('./projections.json', 'utf8'));
}

// Age calc
function calculateAge(birthdateStr: string): number {
  const birthdate = new Date(birthdateStr);
  const today = new Date();
  let age = today.getFullYear() - birthdate.getFullYear();
  const m = today.getMonth() - birthdate.getMonth();
  if (m < 0 || (m === 0 && today.getDate() < birthdate.getDate())) age--;
  return age;
}

// Fallback age
function getFallbackAge(pos: string): number {
  const fallbacks = { WR: 25, RB: 24, TE: 26, QB: 28 };
  return fallbacks[pos] || 25;
}

// Age penalties
const agePenalties = {
  WR: { 27: 0.03, 28: 0.05, 29: 0.07, 30: 0.10, 31: 0.15, '32': 0.20 },
  RB: { 26: 0.05, 27: 0.08, 28: 0.12, 29: 0.18, '30': 0.25 },
  TE: { 29: 0.05, 30: 0.08, 31: 0.10, '32': 0.15 },
  QB: { 35: 0.05, 37: 0.10, '40': 0.15 }
};

// VORP calc with tiers and mode
async function calculateVORP(settings: LeagueSettings, mode: string = 'redraft'): Promise<{ vorpMap: { [key: string]: number }, tiers: any[] }> {
  let projections = await fetchAggregatedProjections();
  if (!projections.length) projections = loadFallbackProjections();

  // Dynasty age decay
  if (mode === 'dynasty') {
    projections = projections.map(p => {
      let age = p.birthdate ? calculateAge(p.birthdate) : getFallbackAge(p.position);
      if (!p.birthdate) console.warn(`Missing birthdate for ${p.player_name} - using fallback age ${age}`);
      const penalties = agePenalties[p.position] || {};
      let penaltyPct = 0;
      for (const [key, pct] of Object.entries(penalties)) {
        if (key.endsWith('+') && age >= parseInt(key.slice(0, -1))) penaltyPct = pct as number;
        else if (age === parseInt(key)) penaltyPct = pct as number;
      }
      p.projected_fpts *= (1 - penaltyPct);
      return p;
    });
  }

  // Baselines and weights (simplified placeholder - expand as needed)
  const vorpMap: { [key: string]: number } = {};
  projections.forEach(p => vorpMap[p.player_name] = p.projected_fpts); // Placeholder VORP - replace with full logic

  // Normalization (placeholder - expand)
  // ...

  // Tier breaks
  const sortedPlayers = projections.sort((a, b) => vorpMap[b.player_name] - vorpMap[a.player_name]);
  const maxVorp = Math.max(...Object.values(vorpMap));
  const tiers = [];
  let currentTier = [sortedPlayers[0]];
  let tierNum = 1;
  for (let i = 1; i < sortedPlayers.length; i++) {
    const drop = (vorpMap[sortedPlayers[i-1].player_name] - vorpMap[sortedPlayers[i].player_name]) / vorpMap[sortedPlayers[i-1].player_name];
    if (drop > 0.15) {
      tiers.push({ tier: tierNum++, players: currentTier });
      currentTier = [sortedPlayers[i]];
    } else {
      currentTier.push(sortedPlayers[i]);
    }
  }
  if (currentTier.length) tiers.push({ tier: tierNum, players: currentTier });

  return { vorpMap, tiers };
}

// Rankings endpoint
app.get('/api/rankings', async (req: Request, res: Response) => {
  const mode = req.query.mode || 'redraft';
  const settings = {}; // Fill from req
  const { vorpMap, tiers } = await calculateVORP(settings as LeagueSettings, mode as string);
  const players = []; // Fill from data
  res.json({ players: players.map(p => ({ ...p, vorp_score: vorpMap[p.player_name] || 50 })), tiers });
});

// Trade-eval
app.post('/api/trade-eval', async (req: Request, res: Response) => {
  const mode = req.body.mode || 'redraft';
  const settings = req.body.settings || {}; // Fill
  const { vorpMap } = await calculateVORP(settings as LeagueSettings, mode);
  // ... (full Lamar code, using vorpMap)
  res.json({ /* response */ });
});

// Cron for weekly refresh
cron.schedule('0 0 * * 0', async () => {
  console.log('Weekly refresh');
  cache.projections = null;
  await fetchAggregatedProjections();
});

app.listen(3000, () => console.log('Server running'));