
üßæ Agent Brief: Migrate DB to Render & Wire Backend

Context
	‚Ä¢	App: TIBER Fantasy (Node/Express, TypeScript)
	‚Ä¢	ORM: Drizzle
	‚Ä¢	Hosting: Render (Web Service)
	‚Ä¢	DB target: Render PostgreSQL
	‚Ä¢	Build/runtime: esbuild ‚Üí CJS (dist/index.cjs)
	‚Ä¢	We want prod to use Render Postgres via DATABASE_URL (with SSL), while dev keeps using local / Replit settings.

Goal (Definition of Done)
	1.	Backend reads process.env.DATABASE_URL and connects to Render Postgres with SSL in production.
	2.	Drizzle config is correct and migrations apply cleanly to Render DB.
	3.	On boot (Render), app runs migrations automatically OR a** documented one-liner** exists to apply migrations.
	4.	Health check /health responds {"ok":true} and a smoke query to the DB returns without error (e.g., SELECT 1 or read from a small table).

Inputs You‚Äôll Need From Me (ask me if missing)
	‚Ä¢	Render Postgres connection string (looks like):
postgres://USER:PASSWORD@HOST:PORT/DBNAME?sslmode=require
	‚Ä¢	If we prefer managed migration at boot or manual migration during deploy.

Constraints
	‚Ä¢	Do not break dev flows. Keep .env for dev; never commit secrets.
	‚Ä¢	Production must require SSL (sslmode=require or node-pg ssl: { rejectUnauthorized: false }).
	‚Ä¢	Keep build output CJS and don‚Äôt introduce ESM-only libs.

‚∏ª

Tasks

1) Add/Verify env plumbing
	‚Ä¢	Ensure we use .env in dev and Render Env Vars in prod.
	‚Ä¢	Files to touch:
	‚Ä¢	.env.example ‚Üí add DATABASE_URL= placeholder (no secret)
	‚Ä¢	Render: set Environment Variable DATABASE_URL=<paste from Render Postgres>

2) Create/verify DB client for prod (node-pg + Drizzle)
	‚Ä¢	Create server/infra/db.ts (or adjust existing) with this template:

// server/infra/db.ts
import { Pool } from "pg";
import { drizzle } from "drizzle-orm/node-postgres";

const connStr = process.env.DATABASE_URL;
if (!connStr) {
  throw new Error("DATABASE_URL is not set");
}

const isProd = process.env.NODE_ENV === "production";

const pool = new Pool({
  connectionString: connStr,
  ssl: isProd ? { rejectUnauthorized: false } : false, // Render requires SSL
});

export const dbPool = pool;
export const db = drizzle(pool);

// optional: tiny sanity check you can call on boot
export async function pingDb() {
  const r = await pool.query("SELECT 1 as ok");
  return r.rows?.[0]?.ok === 1;
}

3) Wire DB init into server boot
	‚Ä¢	In server/index.ts (the one that listens on process.env.PORT), before logging ‚Äúserving on port‚Äù, run a quick sanity check:

import { pingDb } from "./infra/db";

try {
  const ok = await pingDb();
  console.log(ok ? "‚úÖ DB ping ok" : "‚ö†Ô∏è DB ping failed");
} catch (e) {
  console.warn("‚ö†Ô∏è DB ping error (continuing to boot):", e);
}

Keep it non-fatal so app boots even if DB is temporarily slow; we can see it in logs.

4) Drizzle config (drizzle-kit) for Render Postgres
	‚Ä¢	Make sure drizzle.config.ts matches our stack:

// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./server/db/schema.ts",   // <-- adjust to your actual schema file(s)
  out: "./drizzle",                  // migrations folder
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,  // drizzle-kit reads env at runtime
  },
});

	‚Ä¢	Ensure scripts exist in package.json:

{
  "scripts": {
    "db:push": "drizzle-kit push",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio"
  }
}

5) Choose migration strategy (pick one)

Option A ‚Äî Auto-migrate on boot (simple)
	‚Ä¢	Add to server/index.ts (right before listening or right after):

async function autoMigrate() {
  try {
    const { migrate } = await import("drizzle-orm/node-postgres/migrator");
    const { db } = await import("./infra/db");
    // migrations directory generated by drizzle-kit
    await migrate(db, { migrationsFolder: "drizzle" });
    console.log("‚úÖ Drizzle migrations applied");
  } catch (e) {
    console.warn("‚ö†Ô∏è Drizzle auto-migrate failed (continuing):", e);
  }
}
// call it on boot
await autoMigrate();

Option B ‚Äî Manual migration during deploy (clean separation)
	‚Ä¢	No code changes. We‚Äôll run migrations from a one-off command (locally or GitHub Action).
	‚Ä¢	For Render (no SSH), easiest is: run drizzle-kit push locally pointing at the Render DATABASE_URL (export env just for the command), or set up a CI step in GitHub that runs on push to main.

If we choose Option A for now, Agent should implement A. We can switch to B later.

6) Verify and harden
	‚Ä¢	Add a lightweight repo-level check script:

{
  "scripts": {
    "doctor:db": "node -e \"(async()=>{const {pingDb}=await import('./dist/index.cjs');console.log('n/a in repo');})()\""
  }
}

(Or just rely on logs from boot for now.)
	‚Ä¢	Ensure try/catch wraps any DB failure on boot so service still binds the port and Render sees it as healthy.

7) Acceptance tests (Agent should run & show outputs)
	‚Ä¢	Local (Replit):
	1.	DATABASE_URL=<RENDER_URL> npm run db:push (or rely on auto-migrate after npm run build && node dist/index.cjs)
	2.	Observe: ‚Äú‚úÖ Drizzle migrations applied‚Äù and ‚Äú‚úÖ DB ping ok‚Äù
	‚Ä¢	Render:
	1.	Set Env Var DATABASE_URL (sslmode=require) in service Settings
	2.	Deploy
	3.	Logs show:
	‚Ä¢	‚Äú‚úÖ Drizzle migrations applied‚Äù
	‚Ä¢	‚Äú‚úÖ DB ping ok‚Äù
	‚Ä¢	‚Äú[express] serving on port ‚Äù
	4.	GET /health returns { "ok": true }

‚∏ª

Non-negotiables (please enforce)
	‚Ä¢	Never print the full DATABASE_URL in logs.
	‚Ä¢	Always use SSL in production.
	‚Ä¢	Keep dev unaffected: if NODE_ENV !== 'production', we allow local DB (or disable SSL).
	‚Ä¢	If schema folder path is wrong, locate it and update drizzle.config.ts.

Nice to have (if time)
	‚Ä¢	Add a /api/db/health route that returns { connected: true } if pingDb() passes.
	‚Ä¢	Add retry backoff on boot (3√ó, 2s apart) before giving up on migration.

‚∏ª

Quick Notes for You
	‚Ä¢	Your Render Postgres URI typically ends with ?sslmode=require. If not, add it.
	‚Ä¢	If you used Neon previously (@neondatabase/serverless), we‚Äôre not using that for Render Postgres‚Äîstick to pg + node-postgres.

‚∏ª

If you (Agent) hit anything ambiguous (schema path, migrations folder name), search the repo for drizzle-kit, schema, or migrations and update paths accordingly. Report back with:
	‚Ä¢	Files changed
	‚Ä¢	Exact commands run
	‚Ä¢	Boot log snippets proving success
