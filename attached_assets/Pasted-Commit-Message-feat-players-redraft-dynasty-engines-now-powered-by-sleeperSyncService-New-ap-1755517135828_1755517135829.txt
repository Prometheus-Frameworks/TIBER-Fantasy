Commit Message
feat(players): redraft & dynasty engines now powered by sleeperSyncService

- New /api/redraft and /api/dynasty routes (zod-validated, paginated, cached)
- Unified live player feed via sleeperSyncService (QB/RB/WR/TE)
- Redraft: ADP/projection ranking, search/team filters
- Dynasty: Compass-powered scoring (dynasty mode) with per-player cache

Guardrails (read this, Tiber)

No CSVs. No “sample” helpers. All player data comes from sleeperSyncService.getPlayers().

Order matters: register these routes before any SPA * catch-all.

Do not compute heavy stuff across the entire pool—paginate first, then compute for the page slice. We’ll cron precompute later.

Nulls happen. Use null-safe mapping for adp, projected_points, age, team, stats.

1) routes/redraftRoutes.ts
import { Express, Request, Response } from "express";
import { z } from "zod";
import LRU from "lru-cache";
import { sleeperSyncService } from "@/services/sleeperSyncService";

const Query = z.object({
  pos: z.enum(["QB","RB","WR","TE"]).optional(),
  team: z.string().max(3).optional(),
  search: z.string().max(64).optional(),
  page: z.coerce.number().int().min(1).default(1),
  pageSize: z.coerce.number().int().min(10).max(200).default(50),
});

const respCache = new LRU<string, any>({ max: 200, ttl: 5 * 60 * 1000 });

export function registerRedraftRoutes(app: Express) {
  app.get("/api/redraft", async (req: Request, res: Response) => {
    try {
      const q = Query.parse(req.query);
      const key = `redraft:${q.pos ?? "ALL"}:${q.team ?? ""}:${q.search ?? ""}:${q.page}:${q.pageSize}`;
      const cached = respCache.get(key);
      if (cached) return res.json(cached);

      const all = await sleeperSyncService.getPlayers();
      let pool = all.filter((p: any) => ["QB","RB","WR","TE"].includes(p.position));
      if (q.pos) pool = pool.filter((p: any) => p.position === q.pos);
      if (q.team) pool = pool.filter((p: any) => p.team === q.team);
      if (q.search) {
        const s = q.search.toLowerCase();
        pool = pool.filter((p: any) =>
          String(p.full_name || "").toLowerCase().includes(s) ||
          String(p.first_name || "").toLowerCase().includes(s) ||
          String(p.last_name || "").toLowerCase().includes(s)
        );
      }

      // rank by ADP (asc), fallback to projected points (desc)
      pool.sort((a: any, b: any) => {
        const aAdp = a.adp ?? Infinity;
        const bAdp = b.adp ?? Infinity;
        if (aAdp !== bAdp) return aAdp - bAdp;
        return (b.projected_points ?? 0) - (a.projected_points ?? 0);
      });

      const total = pool.length;
      const start = (q.page - 1) * q.pageSize;
      const pageSlice = pool.slice(start, start + q.pageSize);

      const rows = pageSlice.map((p: any) => ({
        id: p.player_id,
        name: p.full_name || `${p.first_name ?? ""} ${p.last_name ?? ""}`.trim(),
        team: p.team ?? null,
        position: p.position,
        age: p.age ?? null,
        adp: p.adp ?? null,
        projectedPoints: p.projected_points ?? null,
        value: p.adp ? (p.projected_points ?? 0) / p.adp : null,
        status: p.status ?? "Active",
        injuryStatus: p.injury_status ?? "Healthy",
      }));

      const payload = {
        ok: true,
        format: "redraft",
        data: rows,
        meta: {
          total,
          page: q.page,
          pageSize: q.pageSize,
          hasNext: q.page * q.pageSize < total,
          ts: new Date().toISOString(),
          source: "Sleeper API → Redraft Engine",
          filters: { pos: q.pos ?? null, team: q.team ?? null, search: q.search ?? null },
        },
      };
      respCache.set(key, payload);
      res.json(payload);
    } catch (err: any) {
      console.error("❌ /api/redraft", err);
      res.status(400).json({ ok: false, error: err?.message ?? "Bad request" });
    }
  });
}

2) routes/dynastyRoutes.ts
import { Express, Request, Response } from "express";
import { z } from "zod";
import LRU from "lru-cache";
import { sleeperSyncService } from "@/services/sleeperSyncService";
import { playerCompassService } from "@/services/playerCompassService";

const Query = z.object({
  pos: z.enum(["QB","RB","WR","TE"]).optional(),
  team: z.string().max(3).optional(),
  search: z.string().max(64).optional(),
  page: z.coerce.number().int().min(1).default(1),
  pageSize: z.coerce.number().int().min(10).max(200).default(50),
});

const pageCache = new LRU<string, any>({ max: 200, ttl: 5 * 60 * 1000 });
const perPlayerCache = new LRU<string, any>({ max: 5000, ttl: 10 * 60 * 1000 });

export function registerDynastyRoutes(app: Express) {
  app.get("/api/dynasty", async (req: Request, res: Response) => {
    try {
      const q = Query.parse(req.query);
      const key = `dynasty:${q.pos ?? "ALL"}:${q.team ?? ""}:${q.search ?? ""}:${q.page}:${q.pageSize}`;
      const cached = pageCache.get(key);
      if (cached) return res.json(cached);

      const all = await sleeperSyncService.getPlayers();
      let pool = all.filter((p: any) => ["QB","RB","WR","TE"].includes(p.position));
      if (q.pos) pool = pool.filter((p: any) => p.position === q.pos);
      if (q.team) pool = pool.filter((p: any) => p.team === q.team);
      if (q.search) {
        const s = q.search.toLowerCase();
        pool = pool.filter((p: any) =>
          String(p.full_name || "").toLowerCase().includes(s) ||
          String(p.first_name || "").toLowerCase().includes(s) ||
          String(p.last_name || "").toLowerCase().includes(s)
        );
      }

      // Seed order: ADP asc then age asc (younger first), then name — cheap pre-sort
      pool.sort((a: any, b: any) =>
        (a.adp ?? Infinity) - (b.adp ?? Infinity) ||
        (a.age ?? 99) - (b.age ?? 99) ||
        String(a.full_name ?? "").localeCompare(String(b.full_name ?? ""))
      );

      const total = pool.length;
      const start = (q.page - 1) * q.pageSize;
      const slice = pool.slice(start, start + q.pageSize);

      const rows = await Promise.all(
        slice.map(async (p: any) => {
          const pid = p.player_id;
          const ck = `comp:${pid}:dynasty`;
          let comp = perPlayerCache.get(ck);
          if (!comp) {
            const input = {
              playerId: pid,
              playerName: p.full_name || `${p.first_name ?? ""} ${p.last_name ?? ""}`.trim(),
              position: p.position,
              team: p.team ?? null,
              age: p.age ?? null,
              rawStats: {
                ...(p.stats ?? {}),
                adp: p.adp ?? null,
                projectedPoints: p.projected_points ?? null,
                ownership: p.ownership_percent ?? null,
              },
              contextTags: p.tags ?? [],
              draftCapital: p.draft_pick ?? null,
              experience: p.years_exp ?? null,
            };
            comp = await playerCompassService.calculateCompass(input, "dynasty");
            perPlayerCache.set(ck, comp);
          }
          return {
            id: pid,
            name: p.full_name || `${p.first_name ?? ""} ${p.last_name ?? ""}`.trim(),
            team: p.team ?? null,
            position: p.position,
            age: p.age ?? null,
            draftPick: p.draft_pick ?? null,
            yearsExp: p.years_exp ?? null,
            adp: p.adp ?? null,
            projectedPoints: p.projected_points ?? null,
            dynastyScore: comp.score,
            tier: comp.tier,
            insights: comp.insights ?? [],
            compass: { north: comp.north, east: comp.east, south: comp.south, west: comp.west },
          };
        })
      );

      // Sort *within the page* by dynastyScore desc, then ADP asc
      rows.sort(
        (a: any, b: any) =>
          (b.dynastyScore ?? -1) - (a.dynastyScore ?? -1) ||
          (a.adp ?? 9999) - (b.adp ?? 9999)
      );

      const payload = {
        ok: true,
        format: "dynasty",
        data: rows,
        meta: {
          total,
          page: q.page,
          pageSize: q.pageSize,
          hasNext: q.page * q.pageSize < total,
          ts: new Date().toISOString(),
          source: "Sleeper API → Dynasty Engine (Compass-powered)",
          filters: { pos: q.pos ?? null, team: q.team ?? null, search: q.search ?? null },
        },
      };
      pageCache.set(key, payload);
      res.json(payload);
    } catch (err: any) {
      console.error("❌ /api/dynasty", err);
      res.status(400).json({ ok: false, error: err?.message ?? "Bad request" });
    }
  });
}


Note on ordering: this computes Compass for the page slice only to avoid CPU bombs. For true global rank order, we’ll add a nightly cron to precompute + persist Compass scores (follow-up PR).

3) Register routes (order!)
// server bootstrap
import { registerRedraftRoutes } from "@/routes/redraftRoutes";
import { registerDynastyRoutes } from "@/routes/dynastyRoutes";

// ... other API routes first
registerRedraftRoutes(app);
registerDynastyRoutes(app);

// SPA catch-all LAST
// app.get("*", ...);

4) Frontend usage (unchanged shape)
// Redraft WRs
fetch("/api/redraft?pos=WR&page=1&pageSize=50");

// Dynasty RBs
fetch("/api/dynasty?pos=RB&page=1&pageSize=50");

Acceptance Tests

Redraft happy path

GET /api/redraft?pos=WR&page=1&pageSize=50
→ 200, ok=true, meta{total,page,pageSize,hasNext}, data[].adp sorted asc


Dynasty happy path

GET /api/dynasty?pos=RB&page=1&pageSize=50
→ 200, ok=true, data[].dynastyScore present, sorted desc within page


Filters

team=KC limits to Chiefs.

search=Jefferson finds Justin.

Pagination

Page 1 vs 2 return different, non-overlapping players; hasNext flips correctly.

Caching

Repeat the same query → second response faster (page cache hit).

Per-player Compass cache hit on repeated dynasty lookups.

Null safety

Missing adp, projected_points, or team doesn’t crash; fields nullable in response.

Follow-ups (don’t block this PR)

Cron precompute Compass & Dynasty ranks (persist to table/Redis); routes read-only.

Injury merge: join with playerInjuries table for live status.

Search speed: if/when search moves server-side DB, add pg_trgm indexes.

Unify meta shape across /api/players, /api/redraft, /api/dynasty (client happiness).

Ship this and your three pillars (Compass, Redraft, Dynasty) all drink from the same live hose. Clean, fast, no ghosts from CSVs haunting the stack.

ChatGP