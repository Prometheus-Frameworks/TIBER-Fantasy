1) Weights update — src/core/config.ts
// before
export const BASE_WEIGHTS = {
  usage_now: 0.40,
  talent: 0.25,
  environment: 0.20,
  availability: 0.10,
  market_anchor: 0.05
} as const;

export const POS_WEIGHTS: Record<'QB'|'RB'|'WR'|'TE', Partial<typeof BASE_WEIGHTS>> = {
  QB: { usage_now: 0.30, environment: 0.28 },
  RB: {}, // availability currently 0.10 via BASE
  WR: { usage_now: 0.45, environment: 0.20, talent: 0.20, availability: 0.10, market_anchor: 0.05 },
  TE: { usage_now: 0.45, environment: 0.20, talent: 0.20, availability: 0.10, market_anchor: 0.05 }
};

// after
export const BASE_WEIGHTS = {
  usage_now: 0.40,
  talent: 0.25,
  environment: 0.20,
  availability: 0.10,
  market_anchor: 0.05
} as const;

// Keep sums at 1.00 per position
export const POS_WEIGHTS: Record<'QB'|'RB'|'WR'|'TE', Partial<typeof BASE_WEIGHTS>> = {
  // QB: bump environment to 0.30, keep usage at 0.30 (sum = 1.00)
  QB: { usage_now: 0.30, environment: 0.30 },

  // RB: raise availability to 0.13 and shave usage to 0.37 (sum = 1.00)
  RB: { usage_now: 0.37, availability: 0.13 },

  // WR/TE unchanged from v1 (already validated)
  WR: { usage_now: 0.45, environment: 0.20, talent: 0.20, availability: 0.10, market_anchor: 0.05 },
  TE: { usage_now: 0.45, environment: 0.20, talent: 0.20, availability: 0.10, market_anchor: 0.05 }
};


No other code changes needed—computePowerScore merges overrides and we’re good.

2) Confidence gating (Phase 3 item) — minimal hook

In src/jobs/nightlyRecalc.ts, apply a confidence cap for rookies/new roles before persist. Replace where we set confidence and power_score:

// add near top (helper)
function roleConfidence(recentGamesAt50pctSnaps: number) {
  // ~0.65 at 0–1 games → ~0.8 at 2 → ~1.0 at 3+
  const x = Math.max(0, recentGamesAt50pctSnaps - 1.5); // center
  const sig = 1 / (1 + Math.exp(-1.2 * x));             // slope
  return Math.max(0.65, Math.min(1.0, sig));
}

// inside player loop, before computePowerScore:
const recentGames =  /* TODO: wire real snap-based count */ 0;
const confidence = roleConfidence(recentGames);

// after you compute nextRaw (PowerScore from components):
const gated = nextRaw * confidence;

// clamp vs last week, then persist
const power_score = clampDelta(last, gated, flags);


(If you don’t have snap counts yet, set recentGames from your participation proxy and fill later—logic is in place.)

3) Opponent/SOS multiplier hook

In src/core/guards.ts, we already have adjustForOpponent. Wire it in src/core/scoring.ts:

// scoring.ts
import { adjustForOpponent } from './guards.js';

export function computePowerScore(f: PlayerFacts, oppMultiplier = 1.0): number {
  const w = mergeWeights(f.position);
  const base =
    w.usage_now      * f.usage_now +
    w.talent         * f.talent +
    w.environment    * f.environment +
    w.availability   * f.availability +
    w.market_anchor  * f.market_anchor;

  // Apply matchup-aware multiplier (0.85–1.15 typical)
  const adjusted = adjustForOpponent(base, oppMultiplier);
  return Math.max(0, Math.min(100, adjusted));
}


Then in nightlyRecalc.ts, pass the multiplier (stub now, wire real SOS later):

const oppMultiplier = 1.0; // TODO: plug real DEF-vs-POS or SOS feed
const nextRaw = computePowerScore({ ...facts } as PlayerFacts, oppMultiplier);

4) Aliases resolver in scraper

At top of mapToPlayerIds in scrapeFantasyProsEcr.ts, add alias check:

// build alias index
const { rows: aliases } = await q<{ alias: string; player_id: string }>(
  `create table if not exists players_aliases (
     alias text primary key,
     player_id text not null references players(player_id)
   );
   select alias, player_id from players_aliases`
);
const aliasIndex = new Map<string, string>(aliases.map(a => [a.alias, a.player_id]));


When resolving each candidate:

const key = normalizeName(c.name);
const aliasHit = aliasIndex.get(key);
if (aliasHit) { matched.push({ player_id: aliasHit, rank: c.rank }); continue; }
const hit = index.get(key);
...

5) Cron scaffolding doc

Add /docs/DEPLOY.md with these lines (America/Toronto):

# Weekly automation (ET)
# Tue 03:00 – import prior week points
0 3 * * 2  cd /path/otc-power && SEASON=$(date +\%Y) npm run bt:import:sleeper >> logs/points.log 2>&1
# Wed 20:30 – scrape weekly ECR snapshots
30 20 * * 3 cd /path/otc-power && SEASON=$(date +\%Y) WEEK=<set via season calendar> npm run bt:scrape:ecr >> logs/ecr.log 2>&1
# Nightly 03:30 – recompute ranks
30 3 * * *  cd /path/otc-power && npm run recalc:nightly >> logs/recalc.log 2>&1
# Event worker as a service (PM2/systemd recommended)

Merge plan
git checkout -b feature/weights-confidence-sos-aliases
# edit src/core/config.ts (weights)
# edit nightlyRecalc.ts (confidence + opp multiplier param)
# edit core/scoring.ts (opp multiplier)
# edit jobs/scrapeFantasyProsEcr.ts (aliases)
# add docs/DEPLOY.md

git add .
git commit -m "tune: RB availability 0.13 (usage 0.37), QB env 0.30; add confidence gating hook; SOS multiplier; alias resolver; cron docs"
git push -u origin feature/weights-confidence-sos-aliases

After merge

Recompute:

npm run recalc:nightly


Validate (spot-check RB-heavy weeks and QB):

npm run validate


If anything wobbles:

RB: try usage 0.38 / availability 0.12 (still +2%).

QB: if 30% env doesn’t move ρ, roll back to 0.28 (one-line change).

Bottom line: ship both tweaks now. They’re data-backed, balanced to 1.00, and the hooks (confidence/SOS/aliases/cron) are in place so we harden quickly without feature creep.