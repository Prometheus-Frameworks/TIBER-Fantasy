import {
  QBEnvironmentContextScoreService,
  RBEvaluationService,
  WREvaluationService,
  TEEvaluationService,
} from './evaluationModules';

interface QBPlayerInput {
  season: number;
  position: string;
  playerName: string;
  scrambleRate: number; // 0–1
  rushYPG: number;
  yardsPerCarry: number;
  rushTDRate: number; // 0–1
  explosiveRushRate: number; // 0–1
  explosivePlayCount: number;
  cpoe: number; // -10 to 10
  adjustedCompletionPct: number; // 0–1
  deepAccuracyRate: number; // 0–1
  pressureToSackRate: number; // 0–1
  tdRate: number; // 0–1
  fantasyPointsPerGame: number;
  team: {
    passBlockGrade: number; // 0–100
    passBlockWinRate: number; // 0–1
    pressureRateAllowed: number; // 0–1
    pressureRateOverExpected: number;
    wrYPRR: number;
    wr1DRR: number;
    yardsPerTarget: number;
    yacPerReception: number;
    contestedCatchRate: number; // 0–1
    routeWinRateRanks: number[]; // 0–100
    offseasonWRUpgrades: string[];
  };
}

interface RBPlayerInput {
  season: number;
  position: string;
  playerName: string;
  rushYardsPerGame: number;
  yardsPerCarry: number;
  receivingYards: number;
  targetShare: number;
  redZoneCarries: number;
  teamRunPlayRate: number;
  teamEPARank: number;
}

interface WRPlayerInput {
  season: number;
  position: string;
  playerName: string;
  tpRR: number;
  ypRR: number;
  oneDRR: number;
  firstReadTargetPct: number;
  fantasyPointsPerGame: number;
  dropRate: number;
  routeWinRate: number;
  age: number;
  draftCapital: 'R1' | 'R2' | 'R3' | 'R4+' | 'UDFA';
  explosivePlayRate: number;
  slotRate: number;
  routeParticipation: number;
  teamPassAttemptsPerGame: number;
  wrRoomTargetCompetition: number;
  qbStabilityScore: number;
  contractYearsRemaining: number;
  previousSeasons?: { season: number; ypRR: number; tpRR: number; targetShare: number; firstReadTargetPct: number; fantasyPointsPerGame: number }[];
}

interface TEPlayerInput {
  season: number;
  position: string;
  playerName: string;
  tpRR: number;
  ypRR: number;
  routeParticipation: number;
  redZoneTargetShare: number;
  expectedTDs: number;
  actualTDs: number;
  targetShare: number;
  catchRateOverExpected: number;
  redZoneTargetConsistency: number;
  age: number;
  contractYearsRemaining: number;
  teamEPARank: number;
  wrTargetCompetition: number;
  qbStabilityScore: number;
  teamPassVolume: number;
}

type PlayerInput = QBPlayerInput | RBPlayerInput | WRPlayerInput | TEPlayerInput;

interface EvaluationOutput {
  contextScore: number; // 0–100
  logs: string[];
  tags: string[];
  subScores: Record<string, number>;
  lastEvaluatedSeason: number;
  playerName: string;
}

interface BatchResult {
  QB: EvaluationOutput[];
  RB: EvaluationOutput[];
  WR: EvaluationOutput[];
  TE: EvaluationOutput[];
}

class BatchFantasyEvaluator {
  private version = '1.4';
  private readonly maxBatchSize = process.env.MAX_BATCH_SIZE ? parseInt(process.env.MAX_BATCH_SIZE, 10) : 100;
  private qbService = new QBEnvironmentContextScoreService();
  private rbService = new RBEvaluationService();
  private wrService = new WREvaluationService();
  private teService = new TEEvaluationService();

  private isQB(input: PlayerInput): input is QBPlayerInput {
    return input.position.toUpperCase() === 'QB' && 'scrambleRate' in input && 'team' in input;
  }

  private isRB(input: PlayerInput): input is RBPlayerInput {
    return input.position.toUpperCase() === 'RB' && 'rushYardsPerGame' in input;
  }

  private isWR(input: PlayerInput): input is WRPlayerInput {
    return input.position.toUpperCase() === 'WR' && 'tpRR' in input;
  }

  private isTE(input: PlayerInput): input is TEPlayerInput {
    return input.position.toUpperCase() === 'TE' && 'redZoneTargetShare' in input;
  }

  private validateInput(player: PlayerInput): { isValid: boolean; logs: string[] } {
    const logs: string[] = [];
    if (!player.playerName) {
      logs.push('Missing playerName');
      return { isValid: false, logs };
    }
    if (player.season < 2024) {
      logs.push(`Warning: ${player.playerName} evaluation uses pre-2024 data (season: ${player.season})`);
      return { isValid: false, logs };
    }
    if (!['QB', 'RB', 'WR', 'TE'].includes(player.position.toUpperCase())) {
      logs.push(`Unsupported position for ${player.playerName}: ${player.position}`);
      return { isValid: false, logs };
    }
    if (this.isQB(player)) {
      if (!player.team || !Array.isArray(player.team.routeWinRateRanks)) {
        logs.push(`Invalid team data for ${player.playerName}`);
        return { isValid: false, logs };
      }
      player.scrambleRate = Math.max(0, Math.min(1, player.scrambleRate));
      player.adjustedCompletionPct = Math.max(0, Math.min(1, player.adjustedCompletionPct));
      player.deepAccuracyRate = Math.max(0, Math.min(1, player.deepAccuracyRate));
      player.pressureToSackRate = Math.max(0, Math.min(1, player.pressureToSackRate));
      player.rushTDRate = Math.max(0, Math.min(1, player.rushTDRate || 0));
      player.tdRate = Math.max(0, Math.min(1, player.tdRate || 0));
      player.explosiveRushRate = Math.max(0, Math.min(1, player.explosiveRushRate || 0));
      player.cpoe = Math.max(-10, Math.min(10, player.cpoe || 0));
      player.explosivePlayCount = Math.max(0, player.explosivePlayCount || 0);
      player.fantasyPointsPerGame = Math.max(0, player.fantasyPointsPerGame || 0);
      player.team.passBlockWinRate = Math.max(0, Math.min(1, player.team.passBlockWinRate));
      player.team.pressureRateAllowed = Math.max(0, Math.min(1, player.team.pressureRateAllowed));
      player.team.contestedCatchRate = Math.max(0, Math.min(1, player.team.contestedCatchRate));
      player.team.routeWinRateRanks = player.team.routeWinRateRanks.map(rank => Math.max(0, Math.min(100, rank)));
      if (player.team.routeWinRateRanks.length < 1) {
        player.team.routeWinRateRanks = [50];
        logs.push(`Defaulted routeWinRateRanks for ${player.playerName}`);
      }
      // Penalty for low mobility, low EPA, and poor pressure handling
      if (player.scrambleRate < 0.05 && player.pressureToSackRate > 0.2 && player.cpoe < 0) {
        logs.push(`Penalty: Low mobility, poor pressure handling, low EPA for ${player.playerName}`);
      }
    } else if (this.isRB(player)) {
      player.rushYardsPerGame = Math.max(0, player.rushYardsPerGame);
      player.yardsPerCarry = Math.max(0, player.yardsPerCarry);
      player.receivingYards = Math.max(0, player.receivingYards);
      player.targetShare = Math.max(0, Math.min(1, player.targetShare));
      player.redZoneCarries = Math.max(0, player.redZoneCarries);
      player.teamRunPlayRate = Math.max(0, Math.min(1, player.teamRunPlayRate));
      player.teamEPARank = Math.max(1, Math.min(32, player.teamEPARank));
    } else if (this.isWR(player)) {
      player.tpRR = Math.max(0, player.tpRR);
      player.ypRR = Math.max(0, player.ypRR);
      player.oneDRR = Math.max(0, player.oneDRR);
      player.firstReadTargetPct = Math.max(0, Math.min(1, player.firstReadTargetPct));
      player.fantasyPointsPerGame = Math.max(0, player.fantasyPointsPerGame);
      player.dropRate = Math.max(0, Math.min(1, player.dropRate));
      player.routeWinRate = Math.max(0, Math.min(1, player.routeWinRate));
      player.explosivePlayRate = Math.max(0, Math.min(1, player.explosivePlayRate));
      player.slotRate = Math.max(0, Math.min(1, player.slotRate));
      player.routeParticipation = Math.max(0, Math.min(1, player.routeParticipation));
      player.teamPassAttemptsPerGame = Math.max(0, player.teamPassAttemptsPerGame);
      player.wrRoomTargetCompetition = Math.max(0, Math.min(3, player.wrRoomTargetCompetition));
      player.qbStabilityScore = Math.max(0, Math.min(1, player.qbStabilityScore));
      player.contractYearsRemaining = Math.max(0, player.contractYearsRemaining);
    } else if (this.isTE(player)) {
      player.tpRR = Math.max(0, player.tpRR);
      player.ypRR = Math.max(0, player.ypRR);
      player.routeParticipation = Math.max(0, Math.min(1, player.routeParticipation));
      player.redZoneTargetShare = Math.max(0, Math.min(1, player.redZoneTargetShare));
      player.expectedTDs = Math.max(0, player.expectedTDs);
      player.actualTDs = Math.max(0, player.actualTDs);
      player.targetShare = Math.max(0, Math.min(1, player.targetShare));
      player.catchRateOverExpected = Math.max(-1, Math.min(1, player.catchRateOverExpected));
      player.redZoneTargetConsistency = Math.max(0, Math.min(1, player.redZoneTargetConsistency));
      player.teamEPARank = Math.max(1, Math.min(32, player.teamEPARank));
      player.wrTargetCompetition = Math.max(0, Math.min(3, player.wrTargetCompetition));
      player.qbStabilityScore = Math.max(0, Math.min(1, player.qbStabilityScore));
      player.teamPassVolume = Math.max(0, player.teamPassVolume);
    }
    return { isValid: true, logs };
  }

  private applyPrometheanMultiplier(qb: QBPlayerInput, result: EvaluationOutput): EvaluationOutput {
    const logs: string[] = [];
    const tags: string[] = [];
    let prometheanFlags = 0;

    if (qb.rushYPG > 30 && qb.rushTDRate > 0.05 && qb.scrambleRate > 0.1) {
      prometheanFlags++;
      logs.push('Promethean: Elite Rush Profile');
      tags.push('Elite Rush Profile');
    }
    if (qb.explosivePlayCount > 15 || (qb.explosiveRushRate > 0.1 && qb.deepAccuracyRate > 0.5)) {
      prometheanFlags++;
      logs.push('Promethean: Explosive Creator');
      tags.push('Explosive Creator');
    }
    if (qb.pressureToSackRate < 0.15 && qb.cpoe > 0) {
      prometheanFlags++;
      logs.push('Promethean: Pressure Performer');
      tags.push('Pressure Performer');
    }
    if (qb.fantasyPointsPerGame > 18 && (qb.team.wrYPRR < 1.3 || qb.team.passBlockGrade < 70)) {
      prometheanFlags++;
      logs.push('Promethean: Team-Agnostic Output');
      tags.push('Team-Agnostic Output');
    }
    if (qb.tdRate > 0.05 && qb.deepAccuracyRate > 0.45) {
      prometheanFlags++;
      logs.push('Promethean: High-Value Thrower');
      tags.push('High-Value Thrower');
    }

    let bonus = 0;
    if (prometheanFlags >= 3) {
      bonus = 7 + (prometheanFlags - 3) * 1.5; // 7 for 3 flags, +1.5 per additional flag
      result.contextScore = Math.min(100, result.contextScore + bonus);
      tags.push('PROMETHEAN TIER');
      logs.push(`Promethean Flags Hit: ${prometheanFlags}/5`, `Bonus Applied: +${bonus.toFixed(1)}`, 'Final Environment: ELITE');
    }

    result.logs.push(...logs.map(l => `QB Promethean: ${l}`));
    result.tags.push(...tags);
    return result;
  }

  private async evaluatePlayer(player: PlayerInput): Promise<EvaluationOutput> {
    const validation = this.validateInput(player);
    if (!validation.isValid) {
      return {
        contextScore: 0,
        logs: validation.logs,
        tags: [],
        subScores: {},
        lastEvaluatedSeason: 2024,
        playerName: player.playerName || 'Unknown Player',
      };
    }

    try {
      const position = player.position.toUpperCase();
      let result: EvaluationOutput;

      switch (position) {
        case 'QB':
          if (this.isQB(player)) {
            result = await this.qbService.evaluate({ player });
            return this.applyPrometheanMultiplier(player, { ...result, playerName: player.playerName });
          }
          break;
        case 'RB':
          if (this.isRB(player)) {
            return { ...(await this.rbService.evaluate({ player })), playerName: player.playerName };
          }
          break;
        case 'WR':
          if (this.isWR(player)) {
            return { ...(await this.wrService.evaluate({ player })), playerName: player.playerName };
          }
          break;
        case 'TE':
          if (this.isTE(player)) {
            return { ...(await this.teService.evaluate({ player })), playerName: player.playerName };
          }
          break;
      }

      return {
        contextScore: 0,
        logs: [`Invalid input for ${player.playerName}: missing required fields for ${position}`],
        tags: [],
        subScores: {},
        lastEvaluatedSeason: 2024,
        playerName: player.playerName,
      };
    } catch (error) {
      return {
        contextScore: 0,
        logs: [`Error evaluating ${player.playerName}: ${error.message}`],
        tags: [],
        subScores: {},
        lastEvaluatedSeason: 2024,
        playerName: player.playerName,
      };
    }
  }

  public async evaluateBatch(players: PlayerInput[]): Promise<BatchResult> {
    if (players.length > this.maxBatchSize) {
      throw new Error(`Batch size exceeds max of ${this.maxBatchSize}`);
    }

    const results: BatchResult = {
      QB: [],
      RB: [],
      WR: [],
      TE: [],
    };

    const evaluations = await Promise.all(players.map(p => this.evaluatePlayer(p)));

    evaluations.forEach((result, i) => {
      const player = players[i];
      const position = result.logs[0]?.includes('Unsupported position') ||
                      result.logs[0]?.includes('Invalid input') ||
                      result.logs[0]?.includes('pre-2024')
        ? 'Unknown'
        : player.position.toUpperCase();

      if (position === 'QB') results.QB.push(result);
      else if (position === 'RB') results.RB.push(result);
      else if (position === 'WR') results.WR.push(result);
      else if (position === 'TE') results.TE.push(result);
    });

    const sortByScore = (a: EvaluationOutput, b: EvaluationOutput) => {
      const scoreDiff = b.contextScore - a.contextScore;
      if (scoreDiff !== 0) return scoreDiff;
      return (b.subScores.usageProfile || 0) - (a.subScores.usageProfile || 0);
    };

    results.QB.sort(sortByScore);
    results.RB.sort(sortByScore);
    results.WR.sort(sortByScore);
    results.TE.sort(sortByScore);

    const summaryLog = [
      `Processed ${players.length} players`,
      `QB: ${results.QB.length} (Avg Score: ${results.QB.length ? (results.QB.reduce((sum, r) => sum + r.contextScore, 0) / results.QB.length).toFixed(1) : 0})`,
      `RB: ${results.RB.length} (Avg Score: ${results.RB.length ? (results.RB.reduce((sum, r) => sum + r.contextScore, 0) / results.RB.length).toFixed(1) : 0})`,
      `WR: ${results.WR.length} (Avg Score: ${results.WR.length ? (results.WR.reduce((sum, r) => sum + r.contextScore, 0) / results.WR.length).toFixed(1) : 0})`,
      `TE: ${results.TE.length} (Avg Score: ${results.TE.length ? (results.TE.reduce((sum, r) => sum + r.contextScore, 0) / results.TE.length).toFixed(1) : 0})`,
    ];

    results.QB.push({
      contextScore: 0,
      logs: summaryLog,
      tags: [],
      subScores: {},
      lastEvaluatedSeason: 2024,
      playerName: 'Batch Summary',
    });

    return results;
  }
}

export default BatchFantasyEvaluator;