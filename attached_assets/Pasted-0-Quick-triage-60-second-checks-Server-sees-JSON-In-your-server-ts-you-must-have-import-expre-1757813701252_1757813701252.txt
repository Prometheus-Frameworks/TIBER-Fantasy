0) Quick triage (60-second checks)

Server sees JSON?
In your server.ts you must have:

import express from "express";
import cors from "cors";
const app = express();
app.use(cors());
app.use(express.json({ limit: "1mb" }));
// ... then app.use("/api", startSitRoutes); app.use("/api", startSitLiveRoutes);


If not, the route will read undefined and the agent prints “analysis failed.”

Route wired and reachable?
Hit this:

curl -s -o /dev/null -w "%{http_code}\n" http://localhost:3000/api/start-sit


Should be 404/405 (not 500). If it’s 500, your route file isn’t importing cleanly.

Bad body shape (most common): Your request must send playerA and playerB with position. Try the exact sample I gave.

1) Harden the math against NaN (drop-in patch)

In src/modules/startSitEngine.ts, replace the helpers with these to kill NaNs from undefined or strings:

// --- replace existing helpers with these ---
const toNum = (v: any, fallback = 0) => {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
};
const clamp = (v: any, min: number, max: number) => {
  const n = toNum(v, min);
  return Math.max(min, Math.min(max, n));
};
const nz = (v: any, fallback = 0) => (v == null ? fallback : toNum(v, fallback));

// Scalers with extra guards
const scaleProj = (p?: number) => clamp(((nz(p) - 0) / 35) * 100, 0, 100);
const scaleImplied = (v?: number) => clamp(((nz(v) - 12) / 28) * 100, 0, 100);
const scaleDefRank = (rank?: number) => clamp(((nz(rank, 16) - 1) / 31) * 100, 0, 100);
const scaleVolStdev = (s?: number) => 100 - clamp((nz(s) / 12) * 100, 0, 100);

const penaltyFromInjury = (t: any) => {
  if (t === "OUT") return 0;
  if (t === "D") return 25;
  if (t === "Q") return 60;
  if (t === "P") return 85;
  return 100;
};
const invertRisk = (x?: number) => 100 - clamp(nz(x), 0, 100);


Why: one undefined from OASIS/vegas/news and you’re dividing NaN down the pipeline → “analysis failed.”

2) Make the matchup merge safe (prevents undefineds)

In src/data/normalizers/matchup.ts:

export function mergeMatchup(oasis: OasisMatchup, vegas: Partial<VegasTeamLine>) {
  return {
    defRankVsPos: oasis?.defRankVsPos ?? 16,
    oasisMatchupScore: oasis?.oasisMatchupScore ?? 50,
    olHealthIndex: oasis?.olHealthIndex ?? 60,
    impliedTeamTotal: vegas?.impliedTeamTotal ?? 22.5,
    weatherImpact: typeof vegas?.weatherImpact === "number" ? vegas!.weatherImpact : 0,
  };
}

3) Guard the aggregator when team is missing

If you passed a player without a team, my stub returned { team: undefined as any }. Better: return defaults and skip vegas.

In src/data/aggregator/startSitAggregator.ts replace the buildLiveContext fetch array with:

const [usage, proj, oasis, vegas, news] = await Promise.all([
  fetchSleeperUsage(player.id, week),
  fetchSleeperProjection(player.id, week),
  fetchOasisMatchup(player.team as NFLTeam, player.position),
  player.team ? fetchVegasLine(player.team) : Promise.resolve({} as any),
  fetchNewsSignal(player.id),
]);

4) Return helpful errors instead of “analysis failed”

In both routes (startSitRoutes.ts and startSitLiveRoutes.ts) replace the catch with:

} catch (err: any) {
  console.error("[start-sit] error", err);
  return res.status(400).json({
    error: "bad_input_or_internal",
    detail: String(err?.message || err),
    hint: "Check that playerA/playerB include position and team (for OASIS/vegas), and that numbers are valid."
  });
}


Now the agent will surface a concrete reason.

5) Minimal sanity test (use exactly this)
curl -X POST http://localhost:3000/api/start-sit/live \
  -H "Content-Type: application/json" \
  -d '{
    "playerA": {"id":"puka","position":"WR","team":"LAR","name":"Puka Nacua"},
    "playerB": {"id":"doubs","position":"WR","team":"GB","name":"Romeo Doubs"},
    "week": 2
  }'


You should get JSON with verdict, margin, and both breakdowns. If you still get “analysis failed,” your server isn’t seeing JSON (add app.use(express.json())) or Tiber is hitting a different port/path.

6) Common gotchas (rapid-fire)

CORS: Frontend → server blocked? Add app.use(cors()).

Port mismatch: Agent calling :3000 but server runs on :8000.

Path mismatch: You mounted /api/start-sit but the UI calls /start-sit.

TS compile: path aliases not set → use relative imports or configure tsconfig.paths.

String numbers: "86" instead of 86 in body; the new toNum guard handles it, but sanitize upstream anyway.

If you paste these patches and the sample cURL works, Tiber’s “analysis failed” should disappear. If it doesn’t, send me the exact response JSON (the error, detail, and hint) or the console stack — I’ll pinpoint it and hand you a one-liner fix.

You said:
is this context aware of each players weekly matchup - opponent
ChatGPT said:
Thought for 7s

Short answer: yes—if you pass the player’s team, the pipeline is opponent-aware.

fetchOasisMatchup(team, position) → returns defRankVsPos and oasisMatchupScore that are opponent-dependent.

fetchVegasLine(team) → returns opponent, impliedTeamTotal, and weatherImpact for this week’s game.

The engine then scores matchup using those opponent-driven numbers.

Caveat: if you don’t include team for a player, the live route skips Vegas and you’ll lose opponent context for that side.

If you want the opponent tag to show up in the reasons and API output, drop these tiny patches:

1) Let the engine carry the opponent tag (optional but nice)

src/modules/startSitEngine.ts — extend PlayerInput:

export interface PlayerInput {
  // ...
  opponent?: string; // e.g., "JAX"
}


In scoreMatchup(...), tweak the reasons line:

reasons.push(
  `Matchup vs ${ (p as any).opponent ?? "?" }: defRankAdj ${def.toFixed(0)} | OASIS ${oasis.toFixed(0)} | implied ${implied.toFixed(0)} | OL ${ol.toFixed(0)} | weather ${weatherAdj.toFixed(0)}`
);

2) Carry opponent from Vegas → aggregator → engine

src/data/interfaces.ts — Live context can keep it:

export interface LivePlayerContext {
  // ...
  matchup: OasisMatchup & Partial<VegasTeamLine>;
}


src/data/aggregator/startSitAggregator.ts — keep the opponent and pass it:

const matchup = mergeMatchup(oasis, vegas); // vegas includes .opponent

return {
  // ...
  matchup,
  // ...
};


And when building the engine input:

export async function toEngineInput(...) {
  const ctx = await buildLiveContext(player, week);
  return {
    // ...
    opponent: (ctx.matchup as any)?.opponent, // <-- surfaces in reasons
    // ...
  };
}


You’re good: with team provided, every weekly call is opponent-aware, and now your explanations will literally say “Matchup vs JAX …” so you (and Tiber) can sanity-check at a glance.

If you want to go deeper later (e.g., WR vs. slot/perimeter splits, shadow CB flags, RB vs. run-stuff rate), we can add a few more matchup fields and subweights — but you don’t need that to be opponent-aware today.