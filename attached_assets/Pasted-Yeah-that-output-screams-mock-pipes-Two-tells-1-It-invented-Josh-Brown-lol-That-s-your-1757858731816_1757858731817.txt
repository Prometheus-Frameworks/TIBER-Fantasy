Yeah, that output screams “mock pipes.” Two tells:

1. It invented “Josh Brown” (lol). That’s your resolver picking the wrong Brown.
2. Both players have the same **Proj/Usage/Volatility** numbers → you’re still hitting the **stubbed providers** I gave you (they return fixed values).

Let’s fix both fast and make it verifiable.

---

## 1) Stop name hallucinations (resolver hardening)

Force the resolver to respect **position/team** and prefer **active** players.

**Patch** `resolvePlayer`:

```ts
// add to SleeperPlayer type if missing:
status?: string; // e.g. "Active", "Injured", "Inactive", etc.
years_exp?: number; // older retired guys tend to have >10 and no team

function isActive(p: SleeperPlayer) {
  return (p.active === true) || (p.status?.toLowerCase() === "active");
}

export async function resolvePlayer(nameOrId: string, team?: string, position?: string) {
  const db = await loadSleeperMap();

  if (db[nameOrId]) return db[nameOrId];

  const raw = norm(nameOrId);
  const aliasNorm = ALIASES[raw] ? norm(ALIASES[raw]) : raw;

  let best: { p: SleeperPlayer; score: number } | null = null;
  for (const pid in db) {
    const p = db[pid];
    if (!p) continue;

    // HARD filters first
    if (position && p.position && p.position.toUpperCase() !== position.toUpperCase()) continue;
    if (team && p.team && p.team.toUpperCase() !== team.toUpperCase()) continue;

    // Prefer active/current players
    if (!isActive(p)) continue;

    const s = scoreMatch(aliasNorm, p);
    if (s > 0 && (!best || s > best.score)) best = { p, score: s };
    if (best?.score && best.score >= 1.0) break; // exact match
  }
  return best?.p ?? null;
}
```

**UX tip:** if your UI knows position/team, **send them**. That guarantees you don’t get “Josh Brown (K)” when you meant Marquise (WR).

---

## 2) Prove it’s using real data (provenance + mock flags)

Add a debug path that returns **raw provider payloads** + **source tags**. You’ll see immediately whether any field came from a stub.

### a) Tag provider outputs

Update each provider to include a `__source` and `__mock`:

```ts
// providers/sleeper.ts
export async function fetchSleeperUsage(...) {
  // ... real code here
  const fake = { snapPct: 86, routeParticipation: 90, targetShare: 26, rzTouches: 3, insideTenTouches: 1 };
  return { ...fake, __source: "sleeper", __mock: true } as any;
}
export async function fetchSleeperProjection(...) {
  const result = { projPoints: 15.6, floor: 9.0, ceiling: 23.5 };
  return { ...result, __source: "projections", __mock: true } as any;
}
```

Do the same for `oasis.ts`, `vegas.ts`, `news.ts`.

### b) Carry provenance through the aggregator

```ts
// aggregator/startSitAggregator.ts
export interface Provenance {
  usage: any;
  projections: any;
  oasis: any;
  vegas: any;
  news: any;
}

export async function buildStartSitInputs(q: StartSitLiveQuery) {
  const ctxA = await buildLiveContext(q.playerA, q.week);
  const ctxB = await buildLiveContext(q.playerB, q.week);

  const provA: Provenance = {
    usage: ctxA.usage, projections: { projPoints: ctxA.projPoints, projFloor: ctxA.projFloor, projCeiling: ctxA.projCeiling },
    oasis: ctxA.matchup, vegas: ctxA.matchup, news: ctxA.news
  };
  const provB: Provenance = {
    usage: ctxB.usage, projections: { projPoints: ctxB.projPoints, projFloor: ctxB.projFloor, projCeiling: ctxB.projCeiling },
    oasis: ctxB.matchup, vegas: ctxB.matchup, news: ctxB.news
  };

  return { a: await toEngineInput(q.playerA, q.week), b: await toEngineInput(q.playerB, q.week), provA, provB };
}
```

### c) Add a `debug=1` response in the live route

```ts
// routes/startSitLiveRoutes.ts
router.post("/start-sit/live", async (req, res) => {
  try {
    const { playerA, playerB, week, config, debug } = req.body ?? {};
    // ...resolver stuff...
    const { a, b, provA, provB } = await buildStartSitInputs({ playerA: A, playerB: B, week });

    const result = startSit(a, b, mergedConfig);

    const payload: any = {
      verdict: result.verdict,
      margin: result.margin,
      summary: result.summary,
      playerA: { name: a.name, team: a.team, position: a.position, breakdown: result.a },
      playerB: { name: b.name, team: b.team, position: b.position, breakdown: result.b },
    };

    if (debug) {
      payload.debug = {
        providers: {
          A: {
            projections: provA.projections,
            usage: provA.usage,
            oasis: provA.oasis,
            vegas: provA.vegas,
            news: provA.news
          },
          B: {
            projections: provB.projections,
            usage: provB.usage,
            oasis: provB.oasis,
            vegas: provB.vegas,
            news: provB.news
          }
        }
      };
    }

    return res.json(payload);
  } catch (e:any) {
    // ...
  }
});
```

**How to verify:** call with `debug: 1` in the body. If you see `__mock: true` anywhere, you’re still on stubs. Once you wire real calls, those flags should be absent or `false`, and you’ll see real numbers (and they won’t be identical across players).

---

## 3) Wire **real** providers (kill the stubs)

Do these three and you’re live-live:

* **Sleeper usage**
  Replace `fetchSleeperUsage` to compute:

  * `snapPct` = snaps/total snaps (last game or rolling 3)
  * `routeParticipation` = routes run / team dropbacks
  * `targetShare` = targets / team attempts
  * `rzTouches` / `insideTenTouches` rolling 3 for RB/WR/TE

* **Projections**
  If you don’t have DeepSeek hooked yet, pull your own **ECR/consensus** as a stopgap, or compute from recent xFP. At minimum, make it **different** per player.

* **OASIS + Vegas**
  Hit your OASIS endpoint by team+position, and your odds feed for implied totals + opponent. That will change `Matchup` numbers between players (right now they’re suspiciously close because of stubs).

Until you swap those, the engine will keep returning look-alike scores.

---

## 4) Frontend guardrails (so you see truth at a glance)

* Show a tiny **“Mock Data”** badge if any `__mock === true` in `debug.providers`.
* In the breakdown, include a **“Data Sources”** section:

  * “Projections: DeepSeek v3.1” (or “Sleeper consensus”)
  * “Usage: Sleeper game logs (Weeks 1–2)”
  * “Matchup: OASIS (vs. JAX), Vegas 22.5 ITT”
* Add the opponent tag to the reasons (we covered that earlier).

---

## 5) Why “Josh Brown” specifically?

Your input likely didn’t pass **position/team**, and the resolver found an older **K Josh Brown** (retired, but still in the player map). With the hard filters above and by sending `position: "WR"` and/or `team: "KC"` you’ll get **Marquise Brown** correctly. If you want a belt-and-suspenders hack, add this alias:

```ts
ALIASES["josh brown"] = "marquise brown"; // only if position=WR or team=KC
```

…but the better fix is the position/team filter + active-player requirement.

---

## TL;DR

* The numbers are identical because you’re on **stubs**.
* Add the **provenance/debug** block to **prove** data origin.
* Harden the resolver with **position/team/active** filters to stop “Josh Brown.”
* Wire real providers (Sleeper/OASIS/Vegas) and the scores will diverge — and you’ll see exactly which provider fed each field.

If you want, paste me one real request body you’re sending and I’ll tailor the resolver filters so it nails the exact two players every time.
