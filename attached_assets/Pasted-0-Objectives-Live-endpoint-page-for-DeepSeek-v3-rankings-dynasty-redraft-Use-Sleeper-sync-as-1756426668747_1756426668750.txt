0) Objectives

Live endpoint & page for DeepSeek v3 rankings (dynasty/redraft).

Use Sleeper sync as source of truth + optional enrichment.

Deterministic scoring with guardrails (dry-run on).

Return {rank, player_id, name, pos, team, age, tier, score, adp?, delta_vs_adp?}.

1) Config (drop in /config/deepseek.v3.weights.json)
{
  "version": "3.0.0",
  "mode_defaults": {
    "dynasty": { "talent": 0.32, "role": 0.16, "context": 0.14, "durability": 0.10, "recency": 0.08, "spike": 0.10, "risk": 0.10 },
    "redraft": { "talent": 0.24, "role": 0.26, "context": 0.16, "durability": 0.08, "recency": 0.16, "spike": 0.08, "risk": 0.02 }
  },
  "tier_cutoffs": [96, 91, 86, 81, 76, 71],
  "guards": {
    "dry_run": true,
    "max_players": 1000,
    "require_sleeper_sync_ok": true,
    "allow_enrichment": true
  }
}

2) Service — /services/deepseekV3Service.ts
import weights from "../config/deepseek.v3.weights.json";
import { getAllPlayers, getAdpMap, getSyncHealth } from "./sleeperSyncService";
import { getOasisTeamEnv } from "./oasisApiService"; // returns { offense:0..100 }
export type Mode = "dynasty"|"redraft";

type Base = {
  player_id: string; name: string; pos: "QB"|"RB"|"WR"|"TE"; team: string;
  age?: number;
  // role/opportunity
  routeRate?: number; tgtShare?: number; rushShare?: number;
  rzTgtShare?: number; glRushShare?: number;
  // talent/efficiency
  talentScore?: number; explosiveness?: number; yakPerRec?: number;
  // recency/spike
  last6wPerf?: number; spikeGravity?: number;
  // risk/insulation
  draftCapTier?: number; injuryRisk?: number; ageRisk?: number;
};

type Row = Base & {
  contextScore?: number; roleScore?: number; durabilityScore?: number;
  recencyScore?: number; talentScoreOut?: number; spikeScore?: number; riskScore?: number;
  score: number; tier: number;
};

const clamp = (x:number, lo=0, hi=99)=>Math.max(lo, Math.min(hi, x));
const bucket = (score:number, cuts:number[]) => cuts.findIndex(c=>score>=c)+1 || cuts.length+1;

async function computeContext(team:string){
  try { const env = await getOasisTeamEnv(team); return clamp(env?.offense ?? 50); }
  catch { return 50; }
}

function computeRole(p:Base){
  const r = (p.routeRate??0)*0.4 + (p.tgtShare??0)*0.4 + (p.rzTgtShare??0)*0.2;
  const rb = (p.rushShare??0)*0.6 + (p.glRushShare??0)*0.4;
  if (p.pos==="RB") return clamp(rb*100);
  if (p.pos==="TE") return clamp(r*95);
  return clamp(r*100);
}
const computeDurability = (p:Base)=>clamp(100 - (p.injuryRisk??20)*1.2 - (p.ageRisk??0)*0.8);
const computeRecency = (p:Base)=>clamp(p.last6wPerf??0);
const computeRisk = (p:Base)=>clamp(0.6*(100-(p.draftCapTier??50)) + 0.4*(p.injuryRisk??20)); // higher=worse
const computeTalent = (p:Base)=>clamp((p.talentScore??0)*0.7 + (p.explosiveness??0)*0.2 + (p.yakPerRec??0)*0.1);
const computeSpike  = (p:Base)=>clamp(p.spikeGravity??0);

export async function buildDeepseekV3(mode:Mode){
  if (weights.guards.require_sleeper_sync_ok) {
    const ok = await getSyncHealth(); // boolean
    if (!ok) throw new Error("sleeper_sync_not_ready");
  }

  const cfg = weights.mode_defaults[mode];
  const all = await getAllPlayers(); // normalized player list with above fields
  const adpMap = await getAdpMap();  // { [player_id]: rankNumber }
  const limited: Base[] = (all as Base[]).slice(0, weights.guards.max_players);

  const rows: Row[] = [];
  for (const p of limited) {
    const [contextScore, roleScore, durabilityScore, recencyScore, talentScoreOut, spikeScore, riskScore] = await Promise.all([
      weights.guards.allow_enrichment ? computeContext(p.team) : Promise.resolve(50),
      Promise.resolve(computeRole(p)),
      Promise.resolve(computeDurability(p)),
      Promise.resolve(computeRecency(p)),
      Promise.resolve(computeTalent(p)),
      Promise.resolve(computeSpike(p)),
      Promise.resolve(computeRisk(p))
    ]);

    const score =
      talentScoreOut * cfg.talent +
      roleScore      * cfg.role +
      contextScore   * cfg.context +
      durabilityScore* cfg.durability +
      recencyScore   * cfg.recency +
      spikeScore     * cfg.spike -
      riskScore      * cfg.risk;

    rows.push({
      ...p, contextScore, roleScore, durabilityScore, recencyScore, talentScoreOut, spikeScore, riskScore,
      score: Math.round(score*100)/100,
      tier: bucket(score, weights.tier_cutoffs)
    });
  }

  rows.sort((a,b)=>b.score - a.score);

  // Attach ADP + delta
  const out = rows.map((r,i)=>{
    const adp = adpMap[r.player_id] ?? null;
    const delta_vs_adp = adp ? Math.round((adp - (i+1))*10)/10 : null;
    return { rank: i+1, ...r, adp, delta_vs_adp };
  });

  if (weights.guards.dry_run) {
    console.log("[DeepSeek v3][dry_run] sample:", out.slice(0,5).map(x=>`${x.rank}. ${x.name} ${x.pos} ${x.score}`));
  }

  return out;
}

3) Route — /routes/rankingsV3.ts
import { Router } from "express";
import { buildDeepseekV3 } from "../services/deepseekV3Service";

const r = Router();

r.get("/api/rankings/deepseek/v3", async (req, res) => {
  try {
    const mode = (req.query.mode as "dynasty"|"redraft") ?? "dynasty";
    const data = await buildDeepseekV3(mode);
    res.json({ mode, count: data.length, ts: Date.now(), data });
  } catch (e:any) {
    res.status(503).json({ error: e?.message ?? "v3_failed" });
  }
});

export default r;

4) Frontend Hook + Table

/web/hooks/useDeepseekV3.ts

import { useEffect, useState } from "react";
export function useDeepseekV3(mode:"dynasty"|"redraft"){
  const [data,setData]=useState<any[]>([]);
  const [meta,setMeta]=useState<{ts?:number;count?:number;mode?:string}>({});
  const [loading,setLoading]=useState(true);
  const [err,setErr]=useState<string|null>(null);
  useEffect(()=>{
    setLoading(true);
    fetch(`/api/rankings/deepseek/v3?mode=${mode}`)
      .then(r=>r.json())
      .then(j=>{ setData(j.data??[]); setMeta({ts:j.ts, count:j.count, mode:j.mode}); })
      .catch(e=>setErr(String(e)))
      .finally(()=>setLoading(false));
  },[mode]);
  return { data, meta, loading, err };
}


/web/components/RankingsV3Table.tsx

import React from "react";
import { useDeepseekV3 } from "../hooks/useDeepseekV3";

export default function RankingsV3Table({mode}:{mode:"dynasty"|"redraft"}){
  const { data, meta, loading, err } = useDeepseekV3(mode);
  if (loading) return <div>Loading DeepSeek v3…</div>;
  if (err) return <div className="text-red-500">Error: {err}</div>;
  return (
    <>
      <div className="flex items-center gap-3 mb-2">
        <h2 className="text-xl font-semibold">DeepSeek v3 — {mode.toUpperCase()}</h2>
        {meta.ts && <span className="text-xs opacity-60">Updated {new Date(meta.ts).toLocaleString()}</span>}
        {meta.count && <span className="text-xs opacity-60">{meta.count} players</span>}
      </div>
      <table className="otc-table w-full">
        <thead>
          <tr>
            <th>#</th><th>Player</th><th>Pos</th><th>Team</th><th>Age</th>
            <th>Tier</th><th>Score</th><th>ADP</th><th>Δ vs ADP</th>
          </tr>
        </thead>
        <tbody>
          {data.map((r:any)=>(
            <tr key={r.player_id}>
              <td>{r.rank}</td>
              <td>{r.name}</td>
              <td>{r.pos}</td>
              <td>{r.team}</td>
              <td>{r.age ?? "-"}</td>
              <td>{r.tier}</td>
              <td>{r.score}</td>
              <td>{r.adp ?? "-"}</td>
              <td>{r.delta_vs_adp ?? "-"}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </>
  );
}


Route/Page stub (add to nav under Research → Rankings v3)

// /web/pages/rankings-v3.tsx
import React, { useState } from "react";
import RankingsV3Table from "../components/RankingsV3Table";
export default function RankingsV3Page(){
  const [mode,setMode]=useState<"dynasty"|"redraft">("dynasty");
  return (
    <div className="p-4">
      <div className="mb-3 flex gap-2">
        <button className={`btn ${mode==="dynasty"?"btn-primary":""}`} onClick={()=>setMode("dynasty")}>Dynasty</button>
        <button className={`btn ${mode==="redraft"?"btn-primary":""}`} onClick={()=>setMode("redraft")}>Redraft</button>
      </div>
      <RankingsV3Table mode={mode}/>
    </div>
  );
}

5) Minimal Tests (server)

Unit test computeRole, computeRisk, and sort order determinism with 5 mocks.

Assert tier bucketing against tier_cutoffs.

Health flag: if require_sleeper_sync_ok and health=false → 503.

(Put in your existing test framework; sample assertions:)

// pseudo-code expectations
expect(bucket(97,[96,91,86,81,76,71])).toBe(1);
expect(bucket(83,[96,91,86,81,76,71])).toBe(4);
expect(computeRisk({draftCapTier:90,injuryRisk:10})).toBeLessThan(computeRisk({draftCapTier:30,injuryRisk:40}));

6) Guardrails & Ops

dry_run=true initially; log top 10 + 5 biggest Δ vs ADP.

max_players=1000 until eyeball check passes.

require_sleeper_sync_ok=true (wire to your existing sync health).

No cron yet. Manual recompute script:

// /scripts/recomputeV3.ts
import { buildDeepseekV3 } from "../services/deepseekV3Service";
(async ()=>{
  const rows = await buildDeepseekV3("dynasty");
  console.log(rows.slice(0,10).map(r=>`${r.rank}. ${r.name} (${r.pos}) — ${r.score}`));
})();

7) Quick QA (go/no-go)

GET /api/rankings/deepseek/v3?mode=dynasty → 200, count>0, fields present.

Flip to redraft → scores/tier mix shifts (recency/role higher).

ADP join works → delta_vs_adp shows risers/fallers.

Change max_players to 200 → count reflects guard.

Toggle dry_run:false → same output, no “dry_run” console.

Page /rankings/v3 renders table within <1s, no console errors.

8) Nice-to-haves (optional tonight)

Add column tooltips: show component subscores on hover.

CSV export of current table.

Link each player → /players/:id rating breakdown (we already have endpoint).

9) Hand-off prompts (copy to Tiber)

A. Wire backend

Implement /api/rankings/deepseek/v3 using the provided deepseekV3Service.ts and route file. Respect deepseek.v3.weights.json guards. Source players from sleeperSyncService, join Sleeper ADP, and return {rank, player_id, name, pos, team, age, tier, score, adp?, delta_vs_adp?}.

B. Add config + guards

Add /config/deepseek.v3.weights.json exactly as provided. Keep dry_run=true, max_players=1000, require_sleeper_sync_ok=true, allow_enrichment=true. Wire health check to our Sleeper sync flag.

C. Frontend page

Create /rankings/v3 with a Dynasty/Redraft toggle and render RankingsV3Table. Show “Updated <timestamp>” and total player count badge.

D. Tests

Add unit tests for role/risk utilities, tier bucketing, and 503 when sync not ready. Basic integration test: endpoint returns ≥100 rows and descending order by score.