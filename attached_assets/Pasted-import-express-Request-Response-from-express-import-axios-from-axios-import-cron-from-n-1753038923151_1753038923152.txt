import express, { Request, Response } from 'express';
import axios from 'axios';
import cron from 'node-cron';
import Fuse from 'fuse.js';

const app = express();
app.use(express.json());

const CACHE_TTL = 60 * 60 * 1000; // 1 hour
const cache = { projections: null as PlayerProjection[] | null, lastFetch: 0 };

interface PlayerProjection {
  player_name: string;
  position: string;
  team: string;
  projected_fpts: number;
  receptions?: number;
  birthdate?: string;
}

interface LeagueSettings {
  format: 'standard' | 'ppr' | 'half-ppr';
  num_teams: number;
  starters: { QB: number; RB: number; WR: number; TE: number; FLEX: number };
  is_superflex: boolean;
  is_te_premium: boolean;
}

// Fetch focused on 2025 projections, fallback to matchups
async function fetchAggregatedProjections(settings: LeagueSettings, source: string = 'season', leagueId?: string, week?: number, skipCache = false): Promise<PlayerProjection[]> {
  if (!skipCache && cache.projections && Date.now() - cache.lastFetch < CACHE_TTL) return cache.projections;

  let aggregated: PlayerProjection[] = [];
  const skipped: { player_name: string; projected_fpts: number }[] = [];

  try {
    const playersResponse = await axios.get('https://api.sleeper.app/v1/players/nfl');
    const playersData = playersResponse.data;

    let projectionsData = {};

    if (source === 'season') {
      const projResponse = await axios.get('https://api.sleeper.com/projections/nfl/2025?season_type=regular&position=QB,RB,WR,TE');
      projectionsData = projResponse.data;

      if (Object.keys(projectionsData).length === 0) {
        console.warn('Season projections empty — fallback to league matchups.');
        source = 'league';
      }
    }

    if (source === 'league' && leagueId && week) {
      const matchupsResponse = await axios.get(`https://api.sleeper.app/v1/league/${leagueId}/matchups/${week}`);
      const matchups = matchupsResponse.data;

      if (matchups && matchups.length > 0) {
        for (const matchup of matchups) {
          const starters = matchup.starters || [];
          const startersPoints = matchup.starters_points || [];
          for (let i = 0; i < starters.length; i++) {
            const playerId = starters[i];
            projectionsData[playerId] = {
              stats: {
                pts_std: startersPoints[i],
                pts_half_ppr: startersPoints[i],
                pts_ppr: startersPoints[i] // League is 1 PPR
              }
            };
          }
        }
      } else {
        console.warn('Matchups empty — no data available.');
        return [];
      }
    }

    for (const playerId in projectionsData) {
      const proj = projectionsData[playerId];
      const player = playersData[playerId];
      if (player && proj && proj.stats) {
        let fpts = 0;
        if (settings.format === 'ppr') fpts = proj.stats.pts_ppr || 0;
        else if (settings.format === 'half-ppr') fpts = proj.stats.pts_half_ppr || 0;
        else fpts = proj.stats.pts_std || 0;

        if (fpts > 450 || fpts <= 50 || !['QB', 'RB', 'WR', 'TE'].includes(player.position) || player.team === null || player.active === false) {
          skipped.push({ player_name: player.full_name || 'Unknown', projected_fpts: fpts });
          continue;
        }

        aggregated.push({
          player_name: player.full_name || `${player.first_name} ${player.last_name}`,
          position: player.position,
          team: player.team || 'FA',
          projected_fpts: fpts,
          receptions: proj.stats.rec || 0,
          birthdate: player.birth_date
        });
      }
    }

    if (skipped.length) console.log('Skipped players:', skipped);

    const fuse = new Fuse(aggregated, { keys: ['player_name', 'position'], threshold: 0.3 });
    const unique = aggregated.filter((p, i) => {
      const matches = fuse.search({ player_name: p.player_name, position: p.position }).filter(m => m.refIndex !== i);
      if (matches.length) {
        matches.forEach(m => {
          aggregated[m.refIndex].projected_fpts = (aggregated[m.refIndex].projected_fpts + p.projected_fpts) / 2;
        });
        return false;
      }
      return true;
    });

    cache.projections = unique;
    cache.lastFetch = Date.now();
    return unique;
  } catch (error) {
    console.error('Sleeper API fetch failed:', error);
    return [];
  }
}

// ... (rest of calculateVORP, endpoints, cron unchanged)

app.listen(3000, () => console.log('Server up'));